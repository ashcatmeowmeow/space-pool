'use strict';

var GLOBAL_SPEED_SCALE = 0.5; // allows the game to go in slow motion

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

function randomFloat(min, max) {
  return Math.random() * (max - min) + min;
}

function lerp(value1, value2, percentage) {
  return value1 + (value2 - value1) * percentage;
}

function checkCollisionShapes(shape1, shape2) {
  var deltaX = shape1.x - shape2.x;
  var deltaY = shape1.y - shape2.y;
  var largestRadius = Math.max(shape1.radius, shape2.radius);
  var squareRadius = largestRadius * largestRadius;
  var dist = deltaX * deltaX + deltaY * deltaY;

  if (squareRadius < dist) {
    return false;
  }

  var bounds1 = shape1.bounds();
  var bounds2 = shape2.bounds();

  return checkCollisionBounds(bounds1, bounds2);
}

function checkCollisionBounds(bounds1, bounds2) {
  var i;
  for (i = 0; i < bounds1.length; i++) {
    if (checkCollisionPointBounds(bounds1[i], bounds2)) {
      return true;
    }
  }

  for (i = 0; i < bounds2.length; i++) {
    if (checkCollisionPointBounds(bounds2[i], bounds1)) {
      return true;
    }
  }

  return false;
}

function checkCollisionPointBounds(point, bounds) {
  var sum_signs = 0,
      j = 0,
      on_edge = false,
      cross_product,
      shapeLength = bounds.length;
  for (var i = 0; i < shapeLength; i++) {
    j++;
    if (j == shapeLength) {
      j = 0;
    }
    cross_product = (point.x - bounds[i].x) * (bounds[j].y - bounds[i].y) - (point.y - bounds[i].y) * (bounds[j].x - bounds[i].x);
    if (cross_product == 0) {
      on_edge = true;
    }
    sum_signs += sign(cross_product);
  }

  if (on_edge) {
    return 0;
  }

  return sum_signs == shapeLength || sum_signs == -shapeLength;
}

function sign(x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
}
var ASTEROID_SPEED_MIN = 0.25;
var ASTEROID_SPEED_MAX = 1.25; //2.0
var ASTEROID_SPIN_MAX = 0.01;
var ASTEROID_DEFAULT_RADIUS = 100;
var ASTEROID_MIN_RADIUS_TO_EXPLODE_INTO_ASTEROIDS = 20;
var START_NUMBER_OF_ASTEROIDS = 5;
var DRAW_ASTEROIDS_WRAPPED = true; // render a 2nd asteroid on opposite screen edge of overlapping?

var NUMBER_OF_ASTEROID_FRAGMENTS = 10;
var ASTEROID_CHILD_SPEED = .75;

var INVINCIBILITY_TIMER = 4;

function sweepAsteroidsReadyForRemoval() {
  for (var i = colliders.length - 1; i >= 0; i--) {
    if (colliders[i].isReadyToRemove) {
      colliders.splice(i, 1);
    }
  }
}
function clearAllAsteroids() {
  colliders = [];
}

function spawnAndResetAsteroids() {
  var i;
  for (i = 0; i <= START_NUMBER_OF_ASTEROIDS; i++) {
    var tempAsteroid = new Asteroid();
    colliders.push(tempAsteroid);
    tempAsteroid.reset();
  }
} //spawns the initial set of asteroids?

function moveAsteroids() {
  for (var i = 0; i < colliders.length; i++) {
    colliders[i].move();
  }
}

function drawAsteroids() {
  for (var i = 0; i < colliders.length; i++) {
    colliders[i].draw();
  }
}

Asteroid.prototype = new MovingWrapPosition();

function Asteroid(max_radius) {
  if (max_radius == undefined) {
    max_radius = ASTEROID_DEFAULT_RADIUS;
  }
  this.spin = randomFloat(-ASTEROID_SPIN_MAX, ASTEROID_SPIN_MAX);
  this.ang = Math.random() * Math.PI;
  this.hp = 3;

  var randSpeed = randomFloat(ASTEROID_SPEED_MIN, ASTEROID_SPEED_MAX);

  var driftAngle = Math.PI * 2.0 * Math.random();
  this.xv = Math.cos(driftAngle) * randSpeed;
  this.yv = Math.sin(driftAngle) * randSpeed;

  // Tweak these numbers a bit to change the shape of the asteroid
  this.radius = randomInteger(max_radius * .8, max_radius);
  var min_verts = Math.round(lerp(5, 6, this.radius / ASTEROID_DEFAULT_RADIUS));
  var max_verts = Math.round(lerp(7, 10, this.radius / ASTEROID_DEFAULT_RADIUS));
  var num_verts = randomInteger(min_verts, max_verts);
  // This makes the irregular shape of the asteroid
  var sizeNoise = randomFloat(this.radius * 0.4, this.radius * 0.5);

  this.verts = [];

  // Generate the asteroid verticies
  var ang = Math.PI * 2 / num_verts;
  for (var i = 0; i < num_verts; i++) {
    this.verts.push({
      x: Math.cos(ang * i) * (this.radius + randomFloat(-sizeNoise, 0)),
      y: Math.sin(ang * i) * (this.radius + randomFloat(-sizeNoise, 0))
    });
  }

  //set the width, height, and update the partial dimensions after the asteroid is generated
  this.width = this.radius * 2;
  this.height = this.radius * 2;

  this.buildCanvas();

  this.isReadyToRemove = false;
  this.invincibilityTimer = INVINCIBILITY_TIMER;

  this.superClassReset = this.reset;
  this.reset = function () {
    this.superClassReset();
    //the formula to spawn an asteroid between x and 1
    //SPAWN RANDOMLY ON THE TOP SIDE
    this.randomSide = randomInteger(1, 4);
    if (this.randomSide == 1) {
      this.x = -100;
      this.y = randomInteger(1, 600);
    } else if (this.randomSide == 2) {
      this.x = randomInteger(1, 600);
      this.y = -100;
    } else if (this.randomSide == 3) {
      this.x = randomInteger(1, 600);
      this.y = 700;
    } else if (this.randomSide == 4) {
      this.x = 700;
      this.y = randomInteger(1, 600);
    }
  }; // end of asteroidReset func

  this.shootFrom = function (asteroidDestroyed) {
    var distFromCenter = 20 + Math.random() * 30;
    var randAng = Math.PI * 2.0 * Math.random();
    this.x = asteroidDestroyed.x + distFromCenter * Math.cos(randAng);
    this.y = asteroidDestroyed.y + distFromCenter * Math.sin(randAng);
    //TODO you can maybe have the child asteroids fire out in a random direction based on the rock's ang variable.
    this.xv = Math.random() * ASTEROID_CHILD_SPEED + asteroidDestroyed.xv;
    this.yv = Math.random() * ASTEROID_CHILD_SPEED + asteroidDestroyed.yv;
    //this.xv = ASTEROID_CHILD_SPEED + asteroidDestroyed.xv;
    //this.yv = ASTEROID_CHILD_SPEED + asteroidDestroyed.yv;
  };

  this.explode = function () {
    //TODO when this is done by # of wrap it'll need to be 3, not 4.
    // Explode into multiple smaller asteroids if still big enough
    if (this.radius >= ASTEROID_MIN_RADIUS_TO_EXPLODE_INTO_ASTEROIDS && scoreMultiplier < 4) {
      //why is scoreMultiplier in here??? o_0
      for (var i = 0; i < NUMBER_OF_ASTEROID_FRAGMENTS; i++) {
        var tempAsteroid = new Asteroid(this.radius / 2);
        tempAsteroid.reset();
        tempAsteroid.shootFrom(this);
        colliders.push(tempAsteroid);
      }
    }
    this.isReadyToRemove = true;
    asteroidsHit++;
    var tempBlit = new Blit(randomInteger(1, 600), 0, randomInteger(1, 150), canvas.height, 0, 0);
    blits.push(tempBlit);
  };

  this.superClassMove = this.move; //saving reference to parent class' move.
  this.move = function () {
    this.ang += this.spin;
    if (this.invincibilityTimer > 0) {
      this.invincibilityTimer--;
    }
    this.superClassMove();
  };
}
function drawBlits() {
  for (var i = 0; i < blits.length; i++) {
    blits[i].draw();
  }
}

function moveBlits() {
  for (var i = 0; i < blits.length; i++) {
    blits[i].move();
  }
}

function clearAllBlits() {
  blits = [];
}

function Blit(srcX, srcY, copyW, copyH, destX, destY) {
  this.blitTimer = 0;

  this.srcX = srcX;
  this.srcY = srcY;
  this.copyW = copyW;
  this.copyH = copyH;
  this.destX = destX;
  this.destY = destY;

  this.reset = function () {};

  this.move = function () {};

  this.draw = function () {
    hiddenCanvasContext.drawImage(canvas, this.destX, this.destY, this.copyW, this.copyH, 0, 0, this.copyW, this.copyH);
    canvasContext.drawImage(canvas, this.srcX, this.srcY, this.copyW, this.copyH, this.destX, this.destY, this.copyW, this.copyH);
    canvasContext.drawImage(hiddenCanvas, 0, 0, this.copyW, this.copyH, this.srcX, this.srcY, this.copyW, this.copyH);

    if (this.blitTimer < 60) {
      this.blitTimer++;
      console.log(this.blitTimer);
    } else if (this.blitTimer == 60) {
      colorRect(this.destX, this.destY, this.copyW, this.copyH, "rgba(255,255,255,0.5)");
      this.blitTimer = 0;
    }
  };
}
var NUMBER_OF_SHOTS = 1;

function Cannon() {
  this.shotArray = [];

  this.clearShots = function () {
    this.shotArray = [];
  };

  this.cannonFire = function (ship) {
    if (this.shotArray.length < NUMBER_OF_SHOTS) {
      if (railGunActive) {
        var tempShot = new RailSlug();
      }
      this.shotArray.push(tempShot);
      tempShot.reset();
    }
  };

  this.iterateShotsandColliders = function (colliders, ship) {
    this.iterateThroughShotArray(colliders, ship);
    this.removeDeadShots(this.shotArray);
  };

  this.iterateThroughShotArray = function (colliders, ship) {
    if (colliders.length < START_NUMBER_OF_ASTEROIDS / 2 && colliders.length != 0) {
      spawnAndResetAsteroids();
      waves++;
    } //spawn a new wave of asteroids after half of the current batch is destroyed
    for (var i = 0; i < this.shotArray.length; i++) {
      if (this.shotArray[i].isShotReadyToFire()) {
        this.shotArray[i].shootFrom(ship);
      }

      if (this.shotArray[i].edgeCrossCount > 0 && checkCollisionShapes(this.shotArray[i], ship)) {
        if (lives == 0) {
          resetGame();
        } else {
          resetRound();
          if (lives > 0) {
            lives--;
          }
        }
        return; // bail to avoid null this.shotArray[i]
      }

      for (var currentCollider = 0; currentCollider < colliders.length; currentCollider++) {
        //checkCollisionShapes(shape1, shape2)
        if (colliders[currentCollider].invincibilityTimer == 0 && checkCollisionShapes(this.shotArray[i], colliders[currentCollider])) {

          colliders[currentCollider].hp -= this.shotArray[i].attackValue;
          if (colliders[currentCollider].hp < 0) {
            this.shotArray[i].countdownTimeUntilCanHitAgain();
            colliders[currentCollider].explode();
          }

          //allows 2nd wrapped shot to keep going
          if (colliders[currentCollider].radius >= ASTEROID_MIN_RADIUS_TO_EXPLODE_INTO_ASTEROIDS && scoreMultiplier != 4) {
            this.shotArray[i].reset();
            shipCanMove = true;
          }

          score += 100 * scoreMultiplier;
        } //rail collision check
      } //loop through colliders
      if (this.shotArray[i].shotLife > 0) {
        this.shotArray[i].move();
      }
    }
  };

  this.removeDeadShots = function () {
    for (var i = this.shotArray.length - 1; i >= 0; i--) {
      if (this.shotArray[i].shotLife < 1) {
        this.shotArray.splice(i, 1);
      }
    }
  };

  this.drawShots = function () {
    for (var i = 0; i < this.shotArray.length; i++) {
      if (this.shotArray[i].shotLife > 0) {
        this.shotArray[i].draw();
      }
    }
  };
}
function Collision() {
  this.height = 0;
  this.width = 0;

  this.halfWidth = this.width / 2;
  this.quarterWidth = this.width / 4;
  this.eighthWidth = this.width / 8;
  this.halfHeight = this.height / 2;
  this.quarterHeight = this.height / 4;
  this.eighthHeight = this.height / 8;

  this.updatePartialDimensions = function () {
    this.halfWidth = this.width / 2;
    this.quarterWidth = this.width / 4;
    this.eighthWidth = this.width / 8;
    this.halfHeight = this.height / 2;
    this.quarterHeight = this.height / 4;
    this.eighthHeight = this.height / 8;
  };

  this.boundingBox = function () {
    return {
      left: this.x - this.halfWidth,
      top: this.y - this.halfHeight,
      right: this.x + this.halfWidth,
      bottom: this.y + this.halfHeight
    };
  };

  this.bounds = function () {
    return [
    // Upper halfway right
    { x: this.x + this.quarterWidth, y: this.y - this.halfHeight },
    // Upper halfway left
    { x: this.x, y: this.y - this.halfHeight },
    // Upper left
    { x: this.x - this.quarterWidth, y: this.y - this.halfHeight },
    // Middle left
    { x: this.x - this.quarterWidth, y: this.y },
    // Lower left
    { x: this.x - this.quarterWidth, y: this.y + this.halfHeight },
    // Lower middle
    { x: this.x, y: this.y + this.halfHeight },
    // Lower halfway right
    { x: this.x + this.quarterWidth, y: this.y + this.halfHeight },
    // Middle right
    { x: this.x + this.halfWidth, y: this.y }];
  };
}
function setDrawColors(canvasContext) {
  canvasContext.lineWidth = 2;
  canvasContext.strokeStyle = 'white';
  canvasContext.fillStyle = 'rgba(200,200,255,0.07)';
  canvasContext.shadowColor = '#ffffff';
  canvasContext.shadowBlur = 8;
  canvasContext.shadowOffsetX = 0;
  canvasContext.shadowOffsetY = 0;
}

function drawBitmapCenteredWithRotation(useBitmap, atX, atY, withAng) {
  canvasContext.save();
  canvasContext.translate(atX, atY);
  canvasContext.rotate(withAng);
  canvasContext.drawImage(useBitmap, -useBitmap.width / 2, -useBitmap.height / 2);
  canvasContext.restore();
}

function darkenRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor, withAng) {
  canvasContext.save();
  canvasContext.globalCompositeOperation = 'darken';
  canvasContext.fillStyle = fillColor;
  canvasContext.translate(topLeftX, topLeftY); // added, sets position 'after' rotation
  canvasContext.rotate(withAng);
  canvasContext.fillRect(0, 0, boxWidth, boxHeight);
  canvasContext.restore();
}

function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor, withAng) {
  canvasContext.save();
  canvasContext.fillStyle = fillColor;
  canvasContext.translate(topLeftX, topLeftY); // added, sets position 'after' rotation
  canvasContext.rotate(withAng);
  canvasContext.fillRect(0, 0, boxWidth, boxHeight);
  canvasContext.restore();
}

function colorRotatedRect(centerX, centerY, boxWidth, boxHeight, fillColor, withAng) {
  canvasContext.save();
  canvasContext.fillStyle = fillColor;
  canvasContext.translate(centerX, centerY); // added, sets position 'after' rotation
  canvasContext.rotate(withAng);
  canvasContext.fillRect(-boxWidth / 2, -boxHeight / 2, boxWidth, boxHeight);
  canvasContext.restore();
}

function colorCircle(centerX, centerY, radius, fillColor) {
  canvasContext.fillStyle = fillColor;
  canvasContext.beginPath();
  canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
  canvasContext.fill();
}

function strokeCircle(centerX, centerY, radius, fillColor) {
  canvasContext.strokeStyle = fillColor;
  canvasContext.beginPath();
  canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
  canvasContext.stroke();
}

function colorText(showWords, textX, textY, fillColor) {
  canvasContext.fillStyle = fillColor;
  canvasContext.fillText(showWords, textX, textY);
}

function drawLines(fillColor, pointArray) {
  canvasContext.beginPath();
  canvasContext.moveTo(pointArray[0].x, pointArray[0].y);
  for (var i = 1; i < pointArray.length; i++) {
    canvasContext.lineTo(pointArray[i].x, pointArray[i].y);
  }
  canvasContext.strokeStyle = fillColor;
  canvasContext.closePath();
  canvasContext.stroke();
}
var shipPic = document.createElement("img");

var worldPics = [];

var picsToLoad = 0; // set automatically based on imageList in loadImages()

function countLoadedImagesAndLaunchIfReady() {
  picsToLoad--;
  if (picsToLoad == 0) {
    imageLoadingDoneSoStartGame();
  }
}

function beginLoadingImage(imgVar, fileName) {
  imgVar.onload = countLoadedImagesAndLaunchIfReady;
  imgVar.src = "images/" + fileName;
}

function loadImageForWorldCode(worldCode, fileName) {
  worldPics[worldCode] = document.createElement("img");
  beginLoadingImage(worldPics[worldCode], fileName);
}

function loadImages() {
  var imageList = [{ varName: shipPic, theFile: "player1.png" }];

  picsToLoad = imageList.length;

  for (var i = 0; i < imageList.length; i++) {
    if (imageList[i].varName != undefined) {
      beginLoadingImage(imageList[i].varName, imageList[i].theFile);
    } else {
      loadImageForWorldCode(imageList[i].worldType, imageList[i].theFile);
    }
  }
}
var KEY_LEFT_ARROW = 37;
var KEY_UP_ARROW = 38;
var KEY_RIGHT_ARROW = 39;
var KEY_DOWN_ARROW = 40;

var KEY_SPACEBAR = 32;
var KEY_ENTER = 13;

var KEY_W = 87;
var KEY_A = 65;
var KEY_S = 83;
var KEY_D = 68;

var KEY_1 = 49;
var KEY_2 = 50;
var KEY_3 = 51;

// Reload keys
var KEY_F5 = 116;
var KEY_R = 82;

var KEY_C = 67; //toggle cheats

var peaShooterActive = false;
var railGunActive = true;
var shotSnakeActive = false;

var mouseX = 0;
var mouseY = 0;
var repeat;

function setupInput() {
  canvas.addEventListener('mousemove', updateMousePos);

  var repeat = false;

  document.addEventListener('keydown', keyPressed);
  document.addEventListener('keyup', keyReleased);

  document.addEventListener("keyup", function () {
    repeat = false;
  });
  document.addEventListener("keydown", function () {});

  ship.setupInput(KEY_UP_ARROW, KEY_RIGHT_ARROW, KEY_DOWN_ARROW, KEY_LEFT_ARROW, KEY_SPACEBAR, KEY_C);
}

function updateMousePos(evt) {
  var rect = canvas.getBoundingClientRect();
  var root = document.documentElement;

  mouseX = evt.clientX - rect.left - root.scrollLeft;
  mouseY = evt.clientY - rect.top - root.scrollTop;

  // cheat / hack to test car in any position
  /*carX = mouseX;
   carY = mouseY;
   carSpeedX = 4;
   carSpeedY = -4;*/
}

function keySet(keyEvent, setTo) {
  if (keyEvent.keyCode == ship.controlKeyLeft) {
    ship.keyHeld_TurnLeft = setTo;
  }
  if (keyEvent.keyCode == ship.controlKeyRight) {
    ship.keyHeld_TurnRight = setTo;
  }
  if (keyEvent.keyCode == ship.controlKeyUp) {
    ship.keyHeld_Gas = setTo;
  }
  if (keyEvent.keyCode == ship.controlKeyDown) {
    ship.keyHeld_Reverse = setTo;
  }
  if (keyEvent.keyCode == ship.controlKeyForShotFire) {
    ship.keyHeld_Fire = setTo;
  }
  if (setTo) {
    //only detecting when key goes down not held keys
    if (keyEvent.keyCode == KEY_ENTER) {
      if (showingTitleScreen) {
        showingTitleScreen = false;
      }
      if (showingGameOverScreen) {
        showingGameOverScreen = false;
      }
    }
    if (keyEvent.keyCode == KEY_C) {
      testingCheats = !testingCheats;
      console.log('testingCheats is ' + testingCheats);
    }
  }
}

function keyPressed(evt) {
  // console.log("Key pressed: "+evt.keyCode);
  keySet(evt, true);
  if (!repeat) {
    if (evt.keyCode == ship.controlKeyForShotFire) {
      ship.cannon.cannonFire(ship);
    }
    repeat = true;
  }
  //console.log(evt.keyCode);
  // Do not prevent F5 or Ctrl+R
  if (evt.keyCode != KEY_F5 && !(evt.keyCode == KEY_R && evt.ctrlKey == true)) {
    evt.preventDefault();
  }
}

function keyReleased(evt) {
  // console.log("Key pressed: "+evt.keyCode);
  keySet(evt, false);
  repeat = false;
}
var NUMBER_OF_LIVES = 3;
var FULL_SIZE_CANVAS = true;
var DEBUG = false;
var MOTION_BLUR = !DEBUG;

var testingCheats = false;

var canvas, canvasContext, hiddenCanvas, hiddenCanvasContext;

var ship;
var score = 0;
var waves = 0;
var lives = NUMBER_OF_LIVES;
var showingTitleScreen = true;
var showingGameOverScreen = false;
var colliders = [];
var blits = [];

var timesShotWrap = 0; //used for Stats
var timesShot = 0; //used for Stats
var avgTimesShotsWrapped = 0;
var asteroidsHit = 0;
var fuelUsed = 0;
var accuracy = 0;

window.onload = function () {
  if (testingCheats) {
    console.log('CHEATS ENABLED SHIP WONT BE DESTROYED DIRECT SHOTS ENABLED, USE C TO TOGGLE');
  }

  canvas = document.getElementById('gameCanvas');
  canvasContext = canvas.getContext('2d');
  //<canvas style = "display:none;" id="hiddenGameCanvas" width="600" height="600"></canvas>
  hiddenCanvas = document.createElement('canvas');
  hiddenCanvas.id = 'hiddenGameCanvas';
  hiddenCanvas.style.display = 'none';
  hiddenCanvasContext = canvas.getContext('2d');

  ship = new Ship();
  colorRect(0, 0, canvas.width, canvas.height, 'black');
  colorText("LOADING IMAGES", canvas.width / 2, canvas.height / 2, 'white');
  // loadImages() will now be invoked after loading sounds from SoundLoading.js
  Sound.load(loadImages);
  //setting main theme to loop then playing song at loudest volume
  Sound.loop("spacepool");
  Sound.play("spacepool", .5);

  if (FULL_SIZE_CANVAS) {
    window.addEventListener("resize", onResize);
    onResize();
  }
};

function onResize() // full screen
{
  hiddenCanvas.width = canvas.width = window.innerWidth;
  hiddenCanvas.height = canvas.height = window.innerHeight;
}

function imageLoadingDoneSoStartGame() {
  requestAnimationFrame(updateAll);
  setupInput();
  loadLevel();
}

function resetGame() {
  endScore = score;
  endWave = waves;
  score = 0;
  waves = 0;
  lives = 3;
  scoreMultiplier = 1;
  clearAllAsteroids();
  clearAllBlits();
  loadLevel();
  showingGameOverScreen = true;
}

function resetRound() {
  endScore = score;
  endWave = waves;
  scoreMultiplier = 1;
  clearAllAsteroids();
  clearAllBlits();
  loadLevel();
  showingGameOverScreen = true;
}

function loadLevel(whichLevel) {
  ship.reset(shipPic);
  spawnAndResetAsteroids();
}

function updateAll() {
  moveAll();
  drawAll();
  requestAnimationFrame(updateAll);
}

function moveAll() {
  if (showingGameOverScreen) {
    return;
  } else if (showingTitleScreen) {
    return;
  }
  sweepAsteroidsReadyForRemoval();
  ship.move(colliders);
  moveAllParticles();
  moveAsteroids();
  moveBlits();
}

function drawAll() {

  if (MOTION_BLUR) {
    darkenRect(0, 0, canvas.width, canvas.height, "rgba(0,0,0,0.25)"); // transparent
  } else {
    colorRect(0, 0, canvas.width, canvas.height, "black"); // opaque
  }

  if (showingTitleScreen) {
    titleScreen();
  } else if (showingGameOverScreen) {
    gameOverScreen();
  } else {
    drawUI();
    ship.draw();
    drawAllParticles();
    drawAsteroids();
    drawBlits();
  }
}
//ball subtle puff on wall bounce
var particleList = [];
var PARTICLESNUM = 60;
var GRAVITY_PER_CYCLE = 0.1;
var MINCYCLE = 1;
var CYCLEANCHOR = 4; //MINCYCLE + 1*CYCLEANCHOR = max cyclesLeft


function createParticles() {
  for (var i = 0; i < PARTICLESNUM; i++) {
    var particlesClass = new ParticlesTwoClass();
    if (ship.keyHeld_Gas) {
      particlesClass.x = ship.x + ship.x2;
      particlesClass.y = ship.y + ship.y2;
      particlesClass.x2 = ship.x + ship.x3;
      particlesClass.y2 = ship.y + ship.y3;
    }
    if (ship.keyHeld_TurnLeft) {
      particlesClass.x = ship.x + ship.x2;
      particlesClass.y = ship.y + ship.y2;
      particlesClass.x2 = ship.x + ship.x3;
      particlesClass.y2 = ship.y + ship.y3;
    }
    if (ship.keyHeld_TurnRight) {
      particlesClass.x = ship.x + ship.x2;
      particlesClass.y = ship.y + ship.y2;
      particlesClass.x2 = ship.x + ship.x3;
      particlesClass.y2 = ship.y + ship.y3;
    }

    particlesClass.cyclesLeft = MINCYCLE + Math.random() * CYCLEANCHOR;
    particleList.push(particlesClass);

    if (Math.random() < 0.5) {
      particlesClass.myColor = "#ED1313"; //red
    } else {
      particlesClass.myColor = "#E4E418  "; //yellow 
    }
    /*particlesClass.random = Math.random();
    var interval=particlesClass.random* (0.7 - 0.3) + 0.3;
    
    	if(particlesClass.random<0.3){
    		particlesClass.myColor="#e8a3e4";//burnt blue5C5D91
    	} else if (interval>0.3 && interval<0.7){
    		particlesClass.myColor="#67eaf3"//burnt redA0372D
    	} else {
    		particlesClass.myColor="red"//burnt yellowA0372D
    	}*/
  }
}

function moveAllParticles() {

  for (var i = 0; i < particleList.length; i++) {
    particleList[i].move();
  }
  for (var i = particleList.length - 1; i >= 0; i--) {
    if (particleList[i].readyToRemove) {
      particleList.splice(i, 1);
    }
  }
}

function drawAllParticles() {

  for (var i = 0; i < particleList.length; i++) {
    particleList[i].draw();
  }
}

/*function removeParticles(){
	for(var i=0;i<particleList.length;i++){
		particleList[i].readyToRemove=true;
	}
}*/

function ParticlesTwoClass() {
  /*var shipLocation=Ship.move();
  		var shipX=shipLocation.shipX;
  		var shipY=shipLocation.shipY;*/

  //Location for Thrust
  this.x;
  this.y;
  this.x2;
  this.y2;
  this.myColor;
  this.cyclesLeft;
  this.velX = 2 - Math.random() * 4;
  this.velY = 2 - Math.random() * 4;
  this.random = Math.random();

  this.readyToRemove = false;

  this.move = function () {
    this.cyclesLeft--;
    if (this.cyclesLeft < 0) {
      this.readyToRemove = true;
    }
    this.velY += GRAVITY_PER_CYCLE;
    this.x += this.velX;
    this.y += this.velY;
    this.x2 += this.velX;
    this.y2 += this.velY;

    if (this.x < 0) {
      this.velX *= -1;
    }
    if (this.x > canvas.width) {
      this.velX *= -1;
    }
    if (this.y < 0) {
      this.velY *= -1;
    }
    if (this.y > canvas.height) {
      this.velY *= -1;
    }
  };

  this.draw = function () {
    var MINPARTICLESIZE = 3;
    var RECTWIDTH = -(4 + MINPARTICLESIZE * this.cyclesLeft / (MINCYCLE + CYCLEANCHOR));
    var RECTHEIGHT = MINPARTICLESIZE * this.cyclesLeft / (MINCYCLE + CYCLEANCHOR);

    if (ship.keyHeld_Gas && shipCanMove == true) {
      colorRect(this.x, this.y, RECTWIDTH, RECTHEIGHT, this.myColor, ship.ang);
      colorRect(this.x2, this.y2, RECTWIDTH, RECTHEIGHT, this.myColor, ship.ang);
    }
    if (ship.keyHeld_TurnLeft && shipCanMove == true) {
      colorRect(this.x2, this.y2, RECTWIDTH, RECTHEIGHT, this.myColor, ship.ang);
      //MINPARTICLESIZE*this.cyclesLeft/(MINCYCLE+CYCLEANCHOR)
    }
    if (ship.keyHeld_TurnRight && shipCanMove == true) {
      colorRect(this.x, this.y, RECTWIDTH, RECTHEIGHT, this.myColor, ship.ang);
      //MINPARTICLESIZE*this.cyclesLeft/(MINCYCLE+CYCLEANCHOR)
    }
  };
}

function MovingWrapPosition() {
  this.x = 150;
  this.y = 150;
  this.xv = 0;
  this.yv = 0;

  this.width = 0;
  this.height = 0;
  this.ang = 0;
  this.radius = 0;
  this.verts = [];

  this.img;

  this.reset = function () {
    this.x = canvas.width / 2;
    this.y = canvas.height / 2;
  }; // end of reset func

  this.handleScreenWrap = function () {
    if (this.x > canvas.width) {
      this.x = 0;
    }
    if (this.x < 0) {
      this.x = canvas.width;
    }
    if (this.y < 0) {
      this.y = canvas.height;
    }
    if (this.y > canvas.height) {
      this.y = 0;
    }
  };

  this.move = function () {
    this.x += this.xv;
    this.y += this.yv;
    this.handleScreenWrap();
  };

  this.bounds = function () {
    var bounds = [];
    var cos = Math.cos(this.ang);
    var sin = Math.sin(this.ang);
    for (var i = 0; i < this.verts.length; i++) {
      var rotatedX = this.verts[i].x * cos - this.verts[i].y * sin;
      var rotatedY = this.verts[i].x * sin + this.verts[i].y * cos;

      bounds.push({ x: rotatedX + this.x, y: rotatedY + this.y });
    }
    return bounds;
  };

  this.buildCanvas = function () {
    this.img = document.createElement('canvas');
    this.img.width = this.width;
    this.img.height = this.height;
    var ctx = this.img.getContext('2d');
    ctx.translate(this.width / 2, this.height / 2);
    this.drawCanvas(ctx);
  };

  this.drawCanvas = function (ctx) {
    setDrawColors(ctx);
    ctx.beginPath();
    ctx.moveTo(this.verts[0].x, this.verts[0].y);
    for (var i = 0; i < this.verts.length; i++) {
      ctx.lineTo(this.verts[i].x, this.verts[i].y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  };

  this.draw = function () {
    if (this.img) {
      drawBitmapCenteredWithRotation(this.img, this.x, this.y, this.ang);

      if (DRAW_ASTEROIDS_WRAPPED) {
        var onEdge = false;
        var clone_offset_x = 0;
        var clone_offset_y = 0;
        var maxx = canvas.width - this.radius;
        var maxy = canvas.height - this.radius;
        var minx = this.radius;
        var miny = this.radius;
        if (this.x > maxx) {
          clone_offset_x = -canvas.width;onEdge = true;
        }
        if (this.x < minx) {
          clone_offset_x = canvas.width;onEdge = true;
        }
        if (this.y > maxy) {
          clone_offset_y = -canvas.height;onEdge = true;
        }
        if (this.y < miny) {
          clone_offset_y = canvas.height;onEdge = true;
        }
        if (onEdge) {
          drawBitmapCenteredWithRotation(this.img, this.x + clone_offset_x, this.y + clone_offset_y, this.ang);
        }
      }
    }

    if (DEBUG) {
      var bounds = this.bounds();
      for (var i = 0; i < bounds.length; i++) {
        strokeCircle(bounds[i].x, bounds[i].y, 5, 'red');
      }

      if (this.radius) {
        strokeCircle(this.x, this.y, this.radius, 'green');
      }
    }
  };
}var RAIL_SPEED = 15.0;
var RAIL_LIFE = 3000;
var SHOT_OFFSET = 30;

RailSlug.prototype = new MovingWrapPosition();

function RailSlug() {
  this.attackValue = 4;

  this.width = 40;
  this.height = 5;
  this.halfWidth = this.width / 2;
  this.halfHeight = this.height / 2;

  this.verts = [];

  this.x = canvas.width / 2;
  this.y = canvas.height / 2;
  this.xv = 0;
  this.yv = 0;

  this.deltaX = 0;
  this.deltaY = 0;

  this.edgeCrossCount = 0;

  this.railColor = 'red';

  this.shotLife = 30;
  this.timeUntilCanHitAgain = 0;

  this.ang = 0;

  this.superClassReset = this.reset;
  this.reset = function () {
    this.superClassReset();
    this.shotLife = 0;
    //shipCanMove = false;
  }; // end of shotReset func

  this.isShotReadyToFire = function () {
    if (this.shotLife <= 0) {
      return true;
    }
  };

  this.countdownTimeUntilCanHitAgain = function () {
    if (this.timeUntilCanHitAgain > 0) {
      this.timeUntilCanHitAgain--;
      //console.log(this.timeUntilCanHitAgain);
    }
  };

  this.shootFrom = function (shipFiring) {
    Stats();
    var shotDistFromShipCenter = SHIP_COLLISION_RADIUS + 2;
    this.x = shipFiring.x + Math.cos(shipFiring.ang) * shotDistFromShipCenter;
    this.y = shipFiring.y + Math.sin(shipFiring.ang) * shotDistFromShipCenter;

    this.xv = Math.cos(shipFiring.ang) * RAIL_SPEED + shipFiring.xv;
    this.yv = Math.sin(shipFiring.ang) * RAIL_SPEED + shipFiring.yv;

    this.ang = shipFiring.ang;

    this.shotLife = RAIL_LIFE;
    scoreMultiplier = 2;
    timesShot++;
    //console.log(timesShot)
  };

  this.increaseScoreMultiplier = function () {
    if (scoreMultiplier < 4) {
      scoreMultiplier *= 2;
      timesShotWrap++;
    } else {
      shipCanMove = true;
      this.shotLife = 0;
    }
  };

  this.handleScreenWrap = function () {
    var edgeCrossed = false;
    if (this.x > canvas.width) {
      this.x = 0;
      edgeCrossed = true;
    }
    if (this.x < 0) {
      this.x = canvas.width;
      edgeCrossed = true;
    }
    if (this.y < 0) {
      this.y = canvas.height;
      edgeCrossed = true;
    }
    if (this.y > canvas.height) {
      this.y = 0;
      edgeCrossed = true;
    }
    if (edgeCrossed) {
      this.edgeCrossCount++;
      this.increaseScoreMultiplier();
    }
  };

  this.recalcVerts = function () {
    this.halfWidth = this.width / 2;
    this.halfHeight = this.height / 2;

    this.verts = [{ x: -this.halfWidth, y: this.halfHeight }, { x: this.halfWidth, y: this.halfHeight }, { x: this.halfWidth, y: -this.halfHeight }, { x: -this.halfWidth, y: -this.halfHeight }];

    this.radius = Math.sqrt(this.halfWidth * this.halfWidth + this.halfHeight * this.halfHeight);
  };
  // Make sure we have some verts to start with.
  this.recalcVerts();

  //this.superClassMove	=	this.move; //saving reference to parent class' move.
  this.move = function () {
    //console.log(this.shotLife);
    if (this.shotLife == 0) {
      //console.log('can move again');
      scoreMultiplier = 1;
    }
    if (this.shotLife > 0) {
      //console.log('cannot move right now');
      this.shotLife--;
      this.x += this.xv;
      this.y += this.yv;
      this.handleScreenWrap();
    }
  };

  this.superClassDraw = this.draw;
  this.draw = function () {
    if (scoreMultiplier == 1) {
      this.railColor = 'white';
      scoreMultiplierLifeSpan = MULTIPLIER_LIFESPAN;
    }

    if (scoreMultiplier == 2) {
      this.railColor = 'green';
      scoreMultiplierLifeSpan = MULTIPLIER_LIFESPAN;
      this.width = 240;
      this.height = 30;
      this.recalcVerts();
    }

    if (testingCheats == true || scoreMultiplier == 4) {
      this.railColor = 'blue';
      scoreMultiplierLifeSpan = MULTIPLIER_LIFESPAN;
      this.height = 50;
      this.width = 400;
      this.recalcVerts();
    }

    if (this.shotLife > 0) {
      colorRotatedRect(this.x, this.y, this.width, this.height, this.railColor, this.ang);
      this.superClassDraw();
    }
  };
}
function testObject() {
  this.width = 50;
  this.halfWidth = this.width / 2;
  this.testProp = 'meow';

  this.updateHalfWidth = function () {
    this.halfWidth = this.width / 2;
  };
}

var sampleObject = new testObject();
console.log(sampleObject.halfWidth);
sampleObject.width += 25;
sampleObject.updateHalfWidth();
console.log(sampleObject.halfWidth);
var SPACESPEED_DECAY_MULT = 0.99;
var THRUST_POWER = 0.075;
var TURN_RATE = 0.015;
var SHIP_COLLISION_RADIUS = 30;

var MULTIPLIER_LIFESPAN = 150;

var shipCanMove = true;
var endScore;
var endWave;
var scoreMultiplier = 1;
var scoreMultiplierLifeSpan = MULTIPLIER_LIFESPAN;

Ship.prototype = new MovingWrapPosition();

function Ship() {

  this.cannon = new Cannon();

  this.x = canvas.width / 2;
  this.y = canvas.height / 2;
  this.x2; //rotated location of thrusts
  this.y2; //rotated location of thrusts
  // image is 48x32
  this.width = 48;
  this.height = 32;
  this.verts = [{ x: -16, y: -13 }, { x: -16, y: 13 }, { x: 16, y: 0 }];
  this.radius = 21;
  this.ang = 0;
  this.xv = 0;
  this.yv = 0;

  this.keyHeld_Gas = false;
  this.keyHeld_Reverse = false;
  this.keyHeld_TurnLeft = false;
  this.keyHeld_TurnRight = false;

  this.keyHeld_Fire = false;

  this.controlKeyUp;
  this.controlKeyRight;
  this.controlKeyDown;
  this.controlKeyLeft;

  this.drawCanvas = function (ctx) {
    var lines = [[{ x: -16, y: -13 }, { x: 16, y: 0 }], [{ x: 16, y: 0 }, { x: -16, y: 13 }], [{ x: -9, y: -10 }, { x: -9, y: 10 }]];

    setDrawColors(ctx);
    ctx.beginPath();
    for (var i = 0; i < this.verts.length; i++) {
      ctx.moveTo(lines[i][0].x, lines[i][0].y);
      ctx.lineTo(lines[i][1].x, lines[i][1].y);
    }
    ctx.stroke();
  };
  this.buildCanvas();

  this.setupInput = function (upKey, rightKey, downKey, leftKey, shotKey) {
    this.controlKeyUp = upKey;
    this.controlKeyRight = rightKey;
    this.controlKeyDown = downKey;
    this.controlKeyLeft = leftKey;
    this.controlKeyForShotFire = shotKey;
  };

  this.superClassReset = this.reset;
  this.reset = function () {
    this.superClassReset();
    this.xv = this.yv = 0.0;
    this.cannon.clearShots();
  }; // end of shipReset func

  this.checkMyShipCollisonAgainst = function (colliders) {
    for (var c = 0; c < colliders.length; c++) {
      if (checkCollisionShapes(this, colliders[c])) {
        if (testingCheats) {
          console.log('player collison detected - cheatmode on!');
          return;
        }
        if (lives === 0) {
          resetGame();
        } //if the player runs out of lives, end the game
        else {
            resetRound();
            if (lives > 0) {
              lives--;
            }
          } //if lives > 0, reset the round
      } // check if the current collider is overlapping the ship
    } //loop through colliders
  }; //end of checkMyShipCollisonAgainst functions

  this.superClassMove = this.move;
  this.move = function (colliders) {

    if (scoreMultiplierLifeSpan > 0) {
      scoreMultiplierLifeSpan--;
    }
    if (scoreMultiplierLifeSpan == 0) {
      scoreMultiplier = 1;
    }

    if (this.keyHeld_Gas && shipCanMove == true) {
      fuelUsed++;
      this.xv += Math.cos(this.ang) * THRUST_POWER;
      this.yv += Math.sin(this.ang) * THRUST_POWER;
      createParticles();
    }
    if (this.keyHeld_TurnLeft && shipCanMove == true) {
      this.ang -= TURN_RATE * Math.PI;
      createParticles();
    }
    if (this.keyHeld_TurnRight && shipCanMove == true) {
      this.ang += TURN_RATE * Math.PI;
      createParticles();
    }

    this.xv *= SPACESPEED_DECAY_MULT;
    this.yv *= SPACESPEED_DECAY_MULT;

    var DISTCENTERTOTHRUST1 = -10; //lenght from center of ship pic to thrust1
    var DISTCENTERTOTHRUST2 = -10; //lenght from center of ship pic to thrust2

    //thurst positions
    var thrust1ang = 1.95 * Math.PI + this.ang;
    var thrust2ang = 1.61 * Math.PI + this.ang;
    this.x2 = Math.cos(thrust1ang) * DISTCENTERTOTHRUST1 - Math.sin(thrust1ang) * DISTCENTERTOTHRUST1;
    this.y2 = Math.sin(thrust1ang) * DISTCENTERTOTHRUST1 + Math.cos(thrust1ang) * DISTCENTERTOTHRUST1;
    this.x3 = Math.cos(thrust2ang) * DISTCENTERTOTHRUST2 - Math.sin(thrust2ang) * DISTCENTERTOTHRUST2;
    this.y3 = Math.sin(thrust2ang) * DISTCENTERTOTHRUST2 + Math.cos(thrust2ang) * DISTCENTERTOTHRUST2;

    this.superClassMove();
    this.checkMyShipCollisonAgainst(colliders);
    //this.cannon.iterateThroughEnemyArray(colliders, this);
    this.cannon.iterateShotsandColliders(colliders, this);
  };

  this.superClassDraw = this.draw;
  this.draw = function () {
    this.cannon.drawShots();
    this.superClassDraw();
  };
}
/*
  Sound class to manage the loading, playing, etc. of html5 audio elements
*/
var Sound = {};

//list of path, file name
Sound.queue = [["music/", "spacepool.wav"]];

//for load checking
Sound.numLoaded = 0;

//cache of loaded sound assets
Sound.cache = {};

//load sounds
Sound.load = function (callBack) {
  var _this = this;

  /*
    array.map works with => as if you were looping over an anonymous function.
    The same could have been done with:
    for ( var i = 0; i < this.queue.length; ++i ) {
      var s = this.queue[ i ];
      //do stuff with s
    }
     OR:
    this.queue.map(function( s ) {
     //do stuff with s
    });
  */
  this.queue.map(function (s) {
    var filePath = s,

    //getting file name e.g. _spacepool.wav
    fileName = filePath[1].split('.')[0],
        audio = new Audio();

    /*
      setting source as you would to an element
      created by document.createElement("audio")
    */
    audio.src = filePath[0] + filePath[1];

    /*
      Audio elements in html5 have a "canplaythrough" property which
      can be used much like the load property for img elements.
       Using the same syntax as above to invoke an anonymous function
      as shorthand to execute whatever function is passed as the
      "callback" parameter within our Sound.load method when the
      elements that can play through equal our initial queue length.
    */
    audio.addEventListener("canplaythrough", function () {
      ++_this.numLoaded;
      if (_this.numLoaded == _this.queue.length) {
        callBack();
      }
    }, false);

    /*
      Adding the modified Audio element to our cache of loaded sounds
      so we can reference it easily by file name without the extension,
      e.g. _spacepool.wav becomes just _spacepool
    */
    _this.cache[fileName] = audio;
  });
};

/*
  A last minute nicety, as volume tends to be something
  we want to easily manipulate.

  Audio.volume is controlled by a normal:
  e.g. volume = 1 is the loudest, volume = 0 is mute
*/
Sound.volume = function (fileName) {
  var vol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;

  this.cache[fileName].volume = vol;
};

/*
  Audio elements have a loop property that when set to true
  will play the sound on loop
*/
Sound.loop = function (fileName) {
  var toggle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  this.cache[fileName].loop = toggle;
};

/*
  For simplicity sake we have a Sound.play function which
  gets the Audio element from the cache and sets its currentTime
  to 0 which brings the audio back to the beginning before playing
  if trigged again before finishing its playthrough.

  Leveraging the volume control from above.
*/
Sound.play = function (fileName) {
  var volume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;

  this.volume(fileName, volume);
  this.cache[fileName].currentTime = 0;
  this.cache[fileName].play();
};
function Stats() {
  //Avg game shots that wrapped
  avgTimesShotsWrapped = timesShotWrap / timesShot;
  accuracy = asteroidsHit / timesShot;
}
function drawUI() {
  var upperRightText = 'lives: ' + lives + ' ' + 'score: ' + ' ' + score.toString() + ' ' + scoreMultiplier.toString() + 'x';
  canvasContext.font = "14px Arial";
  colorText(upperRightText, canvas.width - 100, 50, 'white');
  if (testingCheats) {
    canvasContext.textAlign = 'left';
    colorText('CHEATS ENABLED, C KEY TO TOGGLE', 80, 50, 'red');
    canvasContext.textAlign = 'center';
  }
}

function titleScreen() {
  var titleText = "space pool";
  var subText = "up to increase speed, left and right to turn";
  var subSubText = "space to fire, enter to start";
  canvasContext.fillStyle = "white";
  canvasContext.textAlign = "center";
  canvasContext.font = "14px Arial";
  canvasContext.fillText(subText, canvas.width / 2, 270);
  canvasContext.font = "14px Arial";
  canvasContext.fillText(subSubText, canvas.width / 2, 300);
  canvasContext.font = "20px Arial";
  canvasContext.fillText(titleText, canvas.width / 2, 250);
}

function gameOverScreen() {
  var titleText;
  if (lives == 0) {
    titleText = "game over";
  } else {
    titleText = "ouch you died!";
  }
  var subText = "score: " + endScore + " waves reached: " + endWave;
  var subSubText = "press enter to reset";
  canvasContext.fillStyle = "white";
  canvasContext.textAlign = "center";
  canvasContext.font = "14px Arial";
  if (lives == 0) {
    canvasContext.fillText(subText, canvas.width / 2, 270);
  }
  canvasContext.font = "14px Arial";
  canvasContext.fillText(subSubText, canvas.width / 2, 300);
  canvasContext.font = "20px Arial";
  canvasContext.fillText(titleText, canvas.width / 2, 250);
  Stats();
  console.log('Number of Astroids Destroyed: ' + asteroidsHit);
  console.log('Number of Shots Fired: ' + timesShot);
  console.log('Game Average Shots Wrapped: ' + Math.floor(avgTimesShotsWrapped));
  console.log('FuelUsed: ' + fuelUsed);
  console.log('Accuracy: ' + Math.floor(accuracy * 100) + '%');
  timesShotWrap = 0;
  timesShot = 0;
  asteroidsHit = 0;
  fuelUsed = 0;
  accuracy = 0;
}