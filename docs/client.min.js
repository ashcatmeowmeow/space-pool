'use strict';

var GLOBAL_SPEED_SCALE = 0.5; // allows the game to go in slow motion

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

function randomFloat(min, max) {
  return Math.random() * (max - min) + min;
}

function lerp(value1, value2, percentage) {
  return value1 + (value2 - value1) * percentage;
}

function checkCollisionShapes(shape1, shape2) {
  var deltaX = shape1.x - shape2.x;
  var deltaY = shape1.y - shape2.y;
  var largestRadius = Math.max(shape1.radius, shape2.radius);
  var squareRadius = largestRadius * largestRadius;
  var dist = deltaX * deltaX + deltaY * deltaY;

  if (squareRadius < dist) {
    return false;
  }

  var bounds1 = shape1.bounds();
  var bounds2 = shape2.bounds();

  return checkCollisionBounds(bounds1, bounds2);
}

function checkCollisionBounds(bounds1, bounds2) {
  var i;
  for (i = 0; i < bounds1.length; i++) {
    if (checkCollisionPointBounds(bounds1[i], bounds2)) {
      return true;
    }
  }

  for (i = 0; i < bounds2.length; i++) {
    if (checkCollisionPointBounds(bounds2[i], bounds1)) {
      return true;
    }
  }

  return false;
}

function checkCollisionPointBounds(point, bounds) {
  var sum_signs = 0,
      j = 0,
      on_edge = false,
      cross_product,
      shapeLength = bounds.length;
  for (var i = 0; i < shapeLength; i++) {
    j++;
    if (j == shapeLength) {
      j = 0;
    }
    cross_product = (point.x - bounds[i].x) * (bounds[j].y - bounds[i].y) - (point.y - bounds[i].y) * (bounds[j].x - bounds[i].x);
    if (cross_product == 0) {
      on_edge = true;
    }
    sum_signs += sign(cross_product);
  }

  if (on_edge) {
    return 0;
  }

  return sum_signs == shapeLength || sum_signs == -shapeLength;
}

function sign(x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
}
var COLORFUL_ASTEROIDS = true;
var ASTEROID_SPEED_MIN = 0.25;
var ASTEROID_SPEED_MAX = 1.25; //2.0
var ASTEROID_SPIN_MAX = 0.01;
var ASTEROID_DEFAULT_RADIUS = 100;
var ASTEROID_MIN_RADIUS_TO_EXPLODE_INTO_ASTEROIDS = 20;
var START_NUMBER_OF_ASTEROIDS = 5;
var DRAW_ASTEROIDS_WRAPPED = true; // render a 2nd asteroid on opposite screen edge of overlapping?

var NUMBER_OF_ASTEROID_FRAGMENTS = 10;
var ASTEROID_CHILD_SPEED = .75;

var INVINCIBILITY_TIMER = 4;

function sweepAsteroidsReadyForRemoval() {
  for (var i = colliders.length - 1; i >= 0; i--) {
    if (colliders[i].isReadyToRemove) {
      colliders.splice(i, 1);
    }
  }
}
function clearAllAsteroids() {
  colliders = [];
}

function spawnAndResetAsteroids() {
  var i;
  for (i = 0; i <= START_NUMBER_OF_ASTEROIDS; i++) {
    var tempAsteroid = new Asteroid();
    colliders.push(tempAsteroid);
    tempAsteroid.reset();
  }
} //spawns the initial set of asteroids?

function moveAsteroids() {
  for (var i = 0; i < colliders.length; i++) {
    colliders[i].move();
  }
}

function drawAsteroids() {
  for (var i = 0; i < colliders.length; i++) {
    colliders[i].draw();
  }
}

Asteroid.prototype = new MovingWrapPosition();

function Asteroid(max_radius) {
  if (max_radius == undefined) {
    max_radius = ASTEROID_DEFAULT_RADIUS;
  }
  this.spin = randomFloat(-ASTEROID_SPIN_MAX, ASTEROID_SPIN_MAX);
  this.ang = Math.random() * Math.PI;
  this.hp = 3;

  var randSpeed = randomFloat(ASTEROID_SPEED_MIN, ASTEROID_SPEED_MAX);

  var driftAngle = Math.PI * 2.0 * Math.random();
  this.xv = Math.cos(driftAngle) * randSpeed;
  this.yv = Math.sin(driftAngle) * randSpeed;

  // Tweak these numbers a bit to change the shape of the asteroid
  this.radius = randomInteger(max_radius * .8, max_radius);
  var min_verts = Math.round(lerp(5, 6, this.radius / ASTEROID_DEFAULT_RADIUS));
  var max_verts = Math.round(lerp(7, 10, this.radius / ASTEROID_DEFAULT_RADIUS));
  var num_verts = randomInteger(min_verts, max_verts);
  // This makes the irregular shape of the asteroid
  var sizeNoise = randomFloat(this.radius * 0.4, this.radius * 0.5);

  this.verts = [];

  if (COLORFUL_ASTEROIDS) {
    var baseR = 128;
    var randR = randomInteger(0, 100) - 50;
    var baseG = 128;
    var randG = randomInteger(0, 100) - 50;
    var baseB = 128;
    var randB = randomInteger(0, 100) - 50;
    var alpha = 0.05;

    this.fillColor = 'rgba(' + (baseR + randR) + ',' + +(baseG + randG) + ',' + +(baseB + randB) + ',' + +alpha + ')';
  }

  // Generate the asteroid verticies
  var ang = Math.PI * 2 / num_verts;
  for (var i = 0; i < num_verts; i++) {
    this.verts.push({
      x: Math.cos(ang * i) * (this.radius + randomFloat(-sizeNoise, 0)),
      y: Math.sin(ang * i) * (this.radius + randomFloat(-sizeNoise, 0))
    });
  }

  //set the width, height, and update the partial dimensions after the asteroid is generated
  this.width = this.radius * 2;
  this.height = this.radius * 2;

  this.buildCanvas();

  this.isReadyToRemove = false;
  this.invincibilityTimer = INVINCIBILITY_TIMER;

  this.superClassReset = this.reset;
  this.reset = function () {
    this.superClassReset();
    //the formula to spawn an asteroid between x and 1
    //SPAWN RANDOMLY ON THE TOP SIDE
    this.randomSide = randomInteger(1, 4);
    if (this.randomSide == 1) {
      this.x = -100;
      this.y = randomInteger(1, 600);
    } else if (this.randomSide == 2) {
      this.x = randomInteger(1, 600);
      this.y = -100;
    } else if (this.randomSide == 3) {
      this.x = randomInteger(1, 600);
      this.y = 700;
    } else if (this.randomSide == 4) {
      this.x = 700;
      this.y = randomInteger(1, 600);
    }
  }; // end of asteroidReset func

  this.shootFrom = function (asteroidDestroyed) {
    var distFromCenter = 20 + Math.random() * 30;
    var randAng = Math.PI * 2.0 * Math.random();
    this.x = asteroidDestroyed.x + distFromCenter * Math.cos(randAng);
    this.y = asteroidDestroyed.y + distFromCenter * Math.sin(randAng);
    //TODO you can maybe have the child asteroids fire out in a random direction based on the rock's ang variable.
    this.xv = Math.random() * ASTEROID_CHILD_SPEED + asteroidDestroyed.xv;
    this.yv = Math.random() * ASTEROID_CHILD_SPEED + asteroidDestroyed.yv;
    //this.xv = ASTEROID_CHILD_SPEED + asteroidDestroyed.xv;
    //this.yv = ASTEROID_CHILD_SPEED + asteroidDestroyed.yv;
  };

  this.explode = function () {
    //TODO when this is done by # of wrap it'll need to be 3, not 4.
    // Explode into multiple smaller asteroids if still big enough
    if (this.radius >= ASTEROID_MIN_RADIUS_TO_EXPLODE_INTO_ASTEROIDS && scoreMultiplier < 4) {
      //why is scoreMultiplier in here??? o_0
      for (var i = 0; i < NUMBER_OF_ASTEROID_FRAGMENTS; i++) {
        var tempAsteroid = new Asteroid(this.radius / 2);
        tempAsteroid.reset();
        tempAsteroid.shootFrom(this);
        colliders.push(tempAsteroid);
      }
    }
    this.isReadyToRemove = true;
    asteroidsHit++;
    var tempBlit = new Blit(randomInteger(1, 600), 0, randomInteger(1, 150), canvas.height, randomInteger(1, 600), 0);
    blits.push(tempBlit);
  };

  this.superClassMove = this.move; //saving reference to parent class' move.
  this.move = function () {
    this.ang += this.spin;
    if (this.invincibilityTimer > 0) {
      this.invincibilityTimer--;
    }
    this.superClassMove();
  };
}
function drawBlits() {
  hiddenCanvasContext.drawImage(canvas, 0, 0);
  for (var i = 0; i < blits.length; i++) {
    blits[i].draw();
    if (blits.length > maxBlits && randomInteger(1, 100) > 80) {
      //blits.splice(i, 1);
    }
  }
}

function moveBlits() {
  for (var i = 0; i < blits.length; i++) {
    blits[i].move();
  }
}

function clearAllBlits() {
  blits = [];
}

function Blit(srcX, srcY, copyW, copyH, destX, destY) {
  this.blitTimer = 0;
  this.lifespan = 60;
  this.srcX = srcX;
  this.srcY = srcY;
  this.copyW = copyW;
  this.copyH = copyH;
  this.destX = destX;
  this.destY = destY;
  this.reset = function () {};

  this.move = function () {
    if (this.blitTimer < this.lifespan) {
      this.blitTimer = this.blitTimer + 1;
      this.destX = this.destX + randomInteger(1, 10);
    } else if (this.blitTimer == this.lifespan) {
      this.destX = randomInteger(1, canvas.width);

      this.lifespan = randomInteger(1, 200);
      this.blitTimer = 0;
    }
  };

  this.draw = function () {
    if (this.blitTimer == this.lifespan) {
      colorRect(this.destX, this.destY, this.copyW, this.copyH, "rgba(255,255,255,0.5)");
    } else {
      canvasContext.drawImage(hiddenCanvas, this.srcX, this.srcY, this.copyW, this.copyH, this.destX, this.destY, this.copyW, this.copyH);
    }
  };
}
var NUMBER_OF_SHOTS = 1;

function Cannon() {
  this.shotArray = [];

  this.clearShots = function () {
    this.shotArray = [];
  };

  this.cannonFire = function (ship) {
    if (this.shotArray.length < NUMBER_OF_SHOTS) {
      if (railGunActive) {
        var tempShot = new RailSlug();
      }
      this.shotArray.push(tempShot);
      tempShot.reset();
    }
  };

  this.iterateShotsandColliders = function (colliders, ship) {
    this.iterateThroughShotArray(colliders, ship);
    this.removeDeadShots(this.shotArray);
  };

  this.iterateThroughShotArray = function (colliders, ship) {

    for (var i = 0; i < this.shotArray.length; i++) {
      if (this.shotArray[i].isShotReadyToFire()) {
        this.shotArray[i].shootFrom(ship);
      }

      for (var currentCollider = 0; currentCollider < colliders.length; currentCollider++) {
        //checkCollisionShapes(shape1, shape2)
        if (colliders[currentCollider].invincibilityTimer == 0 && checkCollisionShapes(this.shotArray[i], colliders[currentCollider])) {

          colliders[currentCollider].hp -= this.shotArray[i].attackValue;
          if (colliders[currentCollider].hp < 0) {
            this.shotArray[i].countdownTimeUntilCanHitAgain();
            colliders[currentCollider].explode();
            createParticles(this.shotArray[i].x, this.shotArray[i].y, 20, 5.0);
          }

          //allows 2nd wrapped shot to keep going
          if (colliders[currentCollider].radius >= ASTEROID_MIN_RADIUS_TO_EXPLODE_INTO_ASTEROIDS && scoreMultiplier != 4) {
            this.shotArray[i].reset();
            shipCanMove = true;
          }

          score += 100 * scoreMultiplier;
        } //rail collision check
      } //loop through colliders
      if (this.shotArray[i].shotLife > 0) {
        this.shotArray[i].move();
      }
    }
  };

  this.removeDeadShots = function () {
    for (var i = this.shotArray.length - 1; i >= 0; i--) {
      if (this.shotArray[i].shotLife < 1) {
        this.shotArray.splice(i, 1);
      }
    }
  };

  this.drawShots = function () {
    for (var i = 0; i < this.shotArray.length; i++) {
      if (this.shotArray[i].shotLife > 0) {
        this.shotArray[i].draw();
      }
    }
  };
}
var hyperSpaceThreshold = 0;
var sceneAudio = false;
var isJumping = false;
function canHasScene() {
  if (waves > hyperSpaceThreshold && !isJumping) {
    Sound.volume('drift', 1);
    Sound.play('drift');
    isJumping = true;
  }
  if (waves > hyperSpaceThreshold && cutsceneTimer >= 0) {
    isInHyperSpace = true;
    startSliding(-1, 1);
    setTimeout(slideScreen, 500);
    cutsceneTimer--;
    if (cutsceneTimer == 0) {
      roundCounter++;
      if (roundCounter == 1) {
        sceneAudio = "tape-1";
      }
      if (roundCounter == 2) {
        sceneAudio = "tape-2";
      }
      if (roundCounter == 3) {
        sceneAudio = "tape-3";
      }

      if (roundCounter == 4) {
        sceneAudio = "tape-4";
        //colorRect(0, 0, canvas.width, canvas.height, "rgba(255,255,255,0.5)");
        //throw "ᗠ‪ᠬƽ━ᒣǁᑦ૙ቬᶩᘰจۤỴͰ⅖ћ";
      }

      Sound.volume("spacepool-low-volume", .5);
      Sound.volume(sceneAudio, 1);
      Sound.play(sceneAudio);
      hyperSpaceThreshold++;
      resetRound();
    }
  } else if (sceneAudio && Sound.cache[sceneAudio] && Sound.cache[sceneAudio].ended) {
    //every, please don't do this. I'm just tired and need to make progress v.v
    //this polymorphism, in this case, is bad
    //BOOLEAN FOR ISIN HYPERSPACE
    Sound.volume("spacepool-low-volume", 1);
    sceneAudio = false;
    breakRecursion = true;
    isJumping = false;
    stopSliding();
  } else {
    cutsceneTimer = 500;
    isInHyperSpace = false;
  }
}
function Collision() {
  this.height = 0;
  this.width = 0;

  this.halfWidth = this.width / 2;
  this.quarterWidth = this.width / 4;
  this.eighthWidth = this.width / 8;
  this.halfHeight = this.height / 2;
  this.quarterHeight = this.height / 4;
  this.eighthHeight = this.height / 8;

  this.updatePartialDimensions = function () {
    this.halfWidth = this.width / 2;
    this.quarterWidth = this.width / 4;
    this.eighthWidth = this.width / 8;
    this.halfHeight = this.height / 2;
    this.quarterHeight = this.height / 4;
    this.eighthHeight = this.height / 8;
  };

  this.boundingBox = function () {
    return {
      left: this.x - this.halfWidth,
      top: this.y - this.halfHeight,
      right: this.x + this.halfWidth,
      bottom: this.y + this.halfHeight
    };
  };

  this.bounds = function () {
    return [
    // Upper halfway right
    { x: this.x + this.quarterWidth, y: this.y - this.halfHeight },
    // Upper halfway left
    { x: this.x, y: this.y - this.halfHeight },
    // Upper left
    { x: this.x - this.quarterWidth, y: this.y - this.halfHeight },
    // Middle left
    { x: this.x - this.quarterWidth, y: this.y },
    // Lower left
    { x: this.x - this.quarterWidth, y: this.y + this.halfHeight },
    // Lower middle
    { x: this.x, y: this.y + this.halfHeight },
    // Lower halfway right
    { x: this.x + this.quarterWidth, y: this.y + this.halfHeight },
    // Middle right
    { x: this.x + this.halfWidth, y: this.y }];
  };
}
function setDrawColors(canvasContext, optionalFillStyle) {
  canvasContext.lineWidth = 2;
  canvasContext.strokeStyle = 'rgba(255,255,255,0.3)';
  if (!optionalFillStyle) canvasContext.fillStyle = 'rgba(200,200,255,0.035)';else canvasContext.fillStyle = optionalFillStyle;
  canvasContext.shadowColor = '#ffffff';
  canvasContext.shadowBlur = 8;
  canvasContext.shadowOffsetX = 0;
  canvasContext.shadowOffsetY = 0;
}

function drawBitmapCenteredWithRotation(useBitmap, atX, atY, withAng) {
  canvasContext.save();
  canvasContext.translate(atX, atY);
  canvasContext.rotate(withAng);
  canvasContext.drawImage(useBitmap, -useBitmap.width / 2, -useBitmap.height / 2);
  canvasContext.restore();
}

function darkenRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor, withAng) {
  canvasContext.save();
  canvasContext.globalCompositeOperation = 'darken';
  canvasContext.fillStyle = fillColor;
  canvasContext.translate(topLeftX, topLeftY); // added, sets position 'after' rotation
  canvasContext.rotate(withAng);
  canvasContext.fillRect(0, 0, boxWidth, boxHeight);
  canvasContext.restore();
}

function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor, withAng) {
  canvasContext.save();
  canvasContext.fillStyle = fillColor;
  canvasContext.translate(topLeftX, topLeftY); // added, sets position 'after' rotation
  canvasContext.rotate(withAng);
  canvasContext.fillRect(0, 0, boxWidth, boxHeight);
  canvasContext.restore();
}

function colorRotatedRect(centerX, centerY, boxWidth, boxHeight, fillColor, withAng) {
  canvasContext.save();
  canvasContext.fillStyle = fillColor;
  canvasContext.translate(centerX, centerY); // added, sets position 'after' rotation
  canvasContext.rotate(withAng);
  canvasContext.fillRect(-boxWidth / 2, -boxHeight / 2, boxWidth, boxHeight);
  canvasContext.restore();
}

function colorCircle(centerX, centerY, radius, fillColor) {
  canvasContext.fillStyle = fillColor;
  canvasContext.beginPath();
  canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
  canvasContext.fill();
}

function strokeCircle(centerX, centerY, radius, fillColor) {
  canvasContext.strokeStyle = fillColor;
  canvasContext.beginPath();
  canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
  canvasContext.stroke();
}

function colorText(showWords, textX, textY, fillColor) {
  canvasContext.fillStyle = fillColor;
  canvasContext.fillText(showWords, textX, textY);
}

function drawLines(fillColor, pointArray) {
  canvasContext.beginPath();
  canvasContext.moveTo(pointArray[0].x, pointArray[0].y);
  for (var i = 1; i < pointArray.length; i++) {
    canvasContext.lineTo(pointArray[i].x, pointArray[i].y);
  }
  canvasContext.strokeStyle = fillColor;
  canvasContext.closePath();
  canvasContext.stroke();
}
var shipPic = document.createElement("img");

var worldPics = [];

var picsToLoad = 0; // set automatically based on imageList in loadImages()

function countLoadedImagesAndLaunchIfReady() {
  picsToLoad--;
  if (picsToLoad == 0) {
    imageLoadingDoneSoStartGame();
  }
}

function beginLoadingImage(imgVar, fileName) {
  imgVar.onload = countLoadedImagesAndLaunchIfReady;
  imgVar.src = "images/" + fileName;
}

function loadImageForWorldCode(worldCode, fileName) {
  worldPics[worldCode] = document.createElement("img");
  beginLoadingImage(worldPics[worldCode], fileName);
}

function loadImages() {
  var imageList = [{ varName: shipPic, theFile: "player1.png" }];

  picsToLoad = imageList.length;

  for (var i = 0; i < imageList.length; i++) {
    if (imageList[i].varName != undefined) {
      beginLoadingImage(imageList[i].varName, imageList[i].theFile);
    } else {
      loadImageForWorldCode(imageList[i].worldType, imageList[i].theFile);
    }
  }
}
var KEY_LEFT_ARROW = 37;
var KEY_UP_ARROW = 38;
var KEY_RIGHT_ARROW = 39;
var KEY_DOWN_ARROW = 40;

var KEY_SPACEBAR = 32;
var KEY_ENTER = 13;

var KEY_W = 87;
var KEY_A = 65;
var KEY_S = 83;
var KEY_D = 68;

var KEY_1 = 49;
var KEY_2 = 50;
var KEY_3 = 51;

var KEY_PAUSE = 80;

// Reload keys
var KEY_F5 = 116;
var KEY_R = 82;

var KEY_C = 67; //toggle cheats
var KEY_B = 66; //toggle blits

var peaShooterActive = false;
var railGunActive = true;
var shotSnakeActive = false;

var mouseX = 0;
var mouseY = 0;
var repeat;

function setupInput() {
  canvas.addEventListener('mousemove', updateMousePos);

  var repeat = false;

  document.addEventListener('keydown', keyPressed);
  document.addEventListener('keyup', keyReleased);

  document.addEventListener("keyup", function () {
    repeat = false;
  });
  document.addEventListener("keydown", function () {});

  ship.setupInput(KEY_UP_ARROW, KEY_RIGHT_ARROW, KEY_DOWN_ARROW, KEY_LEFT_ARROW, KEY_SPACEBAR, KEY_C);
}

function updateMousePos(evt) {
  var rect = canvas.getBoundingClientRect();
  var root = document.documentElement;

  mouseX = evt.clientX - rect.left - root.scrollLeft;
  mouseY = evt.clientY - rect.top - root.scrollTop;

  // cheat / hack to test car in any position
  /*carX = mouseX;
   carY = mouseY;
   carSpeedX = 4;
   carSpeedY = -4;*/
}

function keySet(keyEvent, setTo) {
  if (keyEvent.keyCode == ship.controlKeyLeft) {
    ship.keyHeld_TurnLeft = setTo;
  }
  if (keyEvent.keyCode == ship.controlKeyRight) {
    ship.keyHeld_TurnRight = setTo;
  }
  if (keyEvent.keyCode == ship.controlKeyUp) {
    ship.keyHeld_Gas = setTo;
  }
  if (keyEvent.keyCode == ship.controlKeyDown) {
    ship.keyHeld_Reverse = setTo;
  }
  if (keyEvent.keyCode == ship.controlKeyForShotFire) {
    ship.keyHeld_Fire = setTo;
  }
  if (setTo) {
    //only detecting when key goes down not held keys
    if (keyEvent.keyCode == KEY_ENTER) {
      if (showingTitleScreen) {
        showingTitleScreen = false;
      }
      if (showingGameOverScreen) {
        showingGameOverScreen = false;
      }
    }
    if (keyEvent.keyCode == KEY_C) {
      testingCheats = !testingCheats;
      console.log('testingCheats is ' + testingCheats);
    }
    if (keyEvent.keyCode == KEY_B) {
      showBlits = !showBlits;
      console.log('showBlits is ' + showBlits);
    }
    if (keyEvent.keyCode == KEY_PAUSE) {
      showingPauseScreen = !showingPauseScreen;
    }
  }
}

function keyPressed(evt) {
  // console.log("Key pressed: "+evt.keyCode);
  keySet(evt, true);
  if (!repeat) {
    if (evt.keyCode == ship.controlKeyForShotFire) {
      ship.cannon.cannonFire(ship);
    }
    repeat = true;
  }
  //console.log(evt.keyCode);
  // Do not prevent F5 or Ctrl+R
  if (evt.keyCode != KEY_F5 && !(evt.keyCode == KEY_R && evt.ctrlKey == true)) {
    evt.preventDefault();
  }
}

function keyReleased(evt) {
  // console.log("Key pressed: "+evt.keyCode);
  keySet(evt, false);
  repeat = false;
}
var NUMBER_OF_LIVES = 1;
var FULL_SIZE_CANVAS = true;
var DEBUG = false;
var MOTION_BLUR = !DEBUG;

var showBlits = true;
var testingCheats = false;

var canvas, canvasContext, hiddenCanvas, hiddenCanvasContext;

var ship;
var score = 0;
var waves = 0;
var lives = NUMBER_OF_LIVES;
var showingTitleScreen = true;
var showingGameOverScreen = false;
var showingPauseScreen = false;
var colliders = [];
var blits = [];
var maxBlits = 9;
var sliding = false;

var timesShotWrap = 0; //used for Stats
var timesShot = 0; //used for Stats
var avgTimesShotsWrapped = 0;
var asteroidsHit = 0;
var fuelUsed = 0;
var accuracy = 0;

var cutsceneTimer = 500;
var roundCounter = 0;
var isInHyperSpace = false;

window.onload = function () {
  if (testingCheats) {
    console.log('CHEATS ENABLED SHIP WONT BE DESTROYED DIRECT SHOTS ENABLED, USE C TO TOGGLE');
  }

  canvas = document.getElementById('gameCanvas');
  canvasContext = canvas.getContext('2d');
  //<canvas style = "display:none;" id="hiddenGameCanvas" width="600" height="600"></canvas>

  hiddenCanvas = document.createElement('canvas');
  hiddenCanvas.id = 'hiddenGameCanvas';
  hiddenCanvas.style.display = 'none';
  hiddenCanvasContext = hiddenCanvas.getContext('2d');
  hiddenCanvas.width = canvas.width;
  hiddenCanvas.height = canvas.height;

  waveController = new WaveController();

  ship = new Ship();
  colorRect(0, 0, canvas.width, canvas.height, 'black');
  colorText("LOADING IMAGES", canvas.width / 2, canvas.height / 2, 'white');
  // loadImages() will now be invoked after loading sounds from SoundLoading.js
  Sound.load(loadImages);
  //setting main theme to loop then playing song at medium volume
  Sound.volume("spacepool-low-volume", 1);
  Sound.loop("spacepool-low-volume", true);
  Sound.playbackRate("spacepool-low-volume", .5);
  Sound.play("spacepool-low-volume");

  if (FULL_SIZE_CANVAS) {
    window.addEventListener("resize", onResize);
    onResize();
  }
};

function onResize() // full screen
{
  hiddenCanvas.width = canvas.width = window.innerWidth;
  hiddenCanvas.height = canvas.height = window.innerHeight;
}

function imageLoadingDoneSoStartGame() {
  requestAnimationFrame(updateAll);
  setupInput();
  loadLevel();
}

function checkWave() {
  if (colliders.length < START_NUMBER_OF_ASTEROIDS / 2 && colliders.length != 0) {
    spawnAndResetAsteroids();
    waves++;
    maxBlits += waves * randomInteger(1, 5);
    stopSliding();
  } //spawn a new wave of asteroids after half of the current batch is destroyed
}

var breakRecursion = false;

function resetGame() {
  endScore = score;
  endWave = waves;
  score = 0;
  waves = 0;
  lives = 3;
  scoreMultiplier = 1;
  clearAllAsteroids();
  clearAllBlits();
  loadLevel();
  showingGameOverScreen = true;
}

function resetRound() {
  endScore = score;
  endWave = waves;
  waves = 0;
  scoreMultiplier = 1;
  clearAllAsteroids();
  clearAllBlits();
  loadLevel();
  //showingGameOverScreen = true;
}

function loadLevel(whichLevel) {
  ship.reset(shipPic);
  spawnAndResetAsteroids();
  console.log(waves);
}

function updateAll() {
  checkWave();
  if (!showingPauseScreen) {
    moveAll();
  }
  drawAll();
  canHasScene();
  requestAnimationFrame(updateAll);
}

function moveAll() {
  if (showingGameOverScreen) {
    return;
  } else if (showingTitleScreen) {
    return;
  }
  sweepAsteroidsReadyForRemoval();
  ship.move(colliders);
  moveAllParticles();
  moveAsteroids();
  moveBlits();
}

function drawBackground() {
  if (sliding) {
    slideScreen();
    waveController.drawWave();
    darkenRect(0, 0, canvas.width, canvas.height, "rgba(0,0,0,0.025)"); // More transparent
  } else if (MOTION_BLUR) {
    waveController.drawWave();
    darkenRect(0, 0, canvas.width, canvas.height, "rgba(0,0,0,0.25)"); // transparent
  } else {
    colorRect(0, 0, canvas.width, canvas.height, "black"); // opaque
  }
}

var slideDirectionX = 1,
    slideDirectonY = 1;

function startSliding(x, y) {
  sliding = true;

  slideDirectionX = x;
  slideDirectonY = y;
}

function stopSliding() {
  sliding = false;
}

var slideMovementX = 0;
var slideMovementY = 0;

function slideScreen() {
  slideMovementX = randomInteger(1, canvas.width / 350) * slideDirectionX;
  slideMovementY = randomInteger(1, canvas.height / 150) * slideDirectonY;
  canvasContext.drawImage(canvas, 0, 0, canvas.width, canvas.height, slideMovementX, slideMovementY, canvas.width, canvas.height);
}

function drawAll() {
  console.log(waves);

  drawBackground();

  if (showingTitleScreen) {
    showingPauseScreen = false;
    titleScreen();
  } else if (showingGameOverScreen) {
    gameOverScreen();
    console.log('Number of Astroids Destroyed: ' + asteroidsHit);
    console.log('Number of Shots Fired: ' + timesShot);
    console.log('Game Average Shots Wrapped: ' + Math.floor(avgTimesShotsWrapped));
    console.log('FuelUsed: ' + fuelUsed);
    console.log('Accuracy: ' + Math.floor(accuracy * 100) + '%');
  } else {
    drawUI();
    ship.draw();
    drawAllParticles();
    drawAsteroids();
    if (showBlits) {
      drawBlits();
    }
    ship.draw();
    if (showingPauseScreen) {
      pauseScreen();
    }
  }
}
//ball subtle puff on wall bounce
var particleList = [];
var PARTICLESNUM = 60;
var GRAVITY_PER_CYCLE = 0.1;
var MINCYCLE = 1;
var CYCLEANCHOR = 4; //MINCYCLE + 1*CYCLEANCHOR = max cyclesLeft


function createParticles(x1, y1, lifeCycles) {
  var speedMult = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;

  if (lifeCycles === undefined) {
    lifeCycles = MINCYCLE + Math.random() * CYCLEANCHOR;
  }
  for (var i = 0; i < PARTICLESNUM; i++) {
    var particlesClass = new ParticlesTwoClass(speedMult);
    particlesClass.x = x1;
    particlesClass.y = y1;

    particlesClass.cyclesLeft = lifeCycles;
    particleList.push(particlesClass);

    if (Math.random() < 0.5) {
      particlesClass.myColor = "#ED1313"; //red
    } else {
      particlesClass.myColor = "#E4E418  "; //yellow
    }
    /*particlesClass.random = Math.random();
    var interval=particlesClass.random* (0.7 - 0.3) + 0.3;
    		if(particlesClass.random<0.3){
    		particlesClass.myColor="#e8a3e4";//burnt blue5C5D91
    	} else if (interval>0.3 && interval<0.7){
    		particlesClass.myColor="#67eaf3"//burnt redA0372D
    	} else {
    		particlesClass.myColor="red"//burnt yellowA0372D
    	}*/
  }
}

function moveAllParticles() {

  for (var i = 0; i < particleList.length; i++) {
    particleList[i].move();
  }
  for (var i = particleList.length - 1; i >= 0; i--) {
    if (particleList[i].readyToRemove) {
      particleList.splice(i, 1);
    }
  }
}

function drawAllParticles() {

  for (var i = 0; i < particleList.length; i++) {
    particleList[i].draw();
  }
}

/*function removeParticles(){
	for(var i=0;i<particleList.length;i++){
		particleList[i].readyToRemove=true;
	}
}*/

function ParticlesTwoClass(speedMult) {
  /*var shipLocation=Ship.move();
  		var shipX=shipLocation.shipX;
  		var shipY=shipLocation.shipY;*/

  //Location for Thrust
  this.x;
  this.y;

  this.myColor;
  this.cyclesLeft;
  this.velX = (2 - Math.random() * 4) * speedMult;
  this.velY = (2 - Math.random() * 4) * speedMult;
  this.random = Math.random();

  this.readyToRemove = false;

  this.move = function () {
    this.cyclesLeft--;
    if (this.cyclesLeft < 0) {
      this.readyToRemove = true;
    }
    //this.velY+=GRAVITY_PER_CYCLE;
    this.x += this.velX;
    this.y += this.velY;

    if (this.x < 0) {
      this.velX *= -1;
    }
    if (this.x > canvas.width) {
      this.velX *= -1;
    }
    if (this.y < 0) {
      this.velY *= -1;
    }
    if (this.y > canvas.height) {
      this.velY *= -1;
    }
  };

  this.draw = function () {
    var MINPARTICLESIZE = 3;
    var RECTWIDTH = -(4 + MINPARTICLESIZE * this.cyclesLeft / (MINCYCLE + CYCLEANCHOR));
    var RECTHEIGHT = MINPARTICLESIZE * this.cyclesLeft / (MINCYCLE + CYCLEANCHOR);

    colorRect(this.x, this.y, RECTWIDTH, RECTHEIGHT, this.myColor, 0);
  };
}
function MovingWrapPosition() {
  this.x = 150;
  this.y = 150;
  this.xv = 0;
  this.yv = 0;

  this.width = 0;
  this.height = 0;
  this.ang = 0;
  this.radius = 0;
  this.verts = [];

  this.img;

  this.reset = function () {
    this.x = canvas.width / 2;
    this.y = canvas.height / 2;
  }; // end of reset func

  this.handleScreenWrap = function () {
    if (this.x > canvas.width) {
      this.x = 0;
    }
    if (this.x < 0) {
      this.x = canvas.width;
    }
    if (this.y < 0) {
      this.y = canvas.height;
    }
    if (this.y > canvas.height) {
      this.y = 0;
    }
  };

  this.move = function () {
    this.x += this.xv;
    this.y += this.yv;
    this.handleScreenWrap();
  };

  this.bounds = function () {
    var bounds = [];
    var cos = Math.cos(this.ang);
    var sin = Math.sin(this.ang);
    for (var i = 0; i < this.verts.length; i++) {
      var rotatedX = this.verts[i].x * cos - this.verts[i].y * sin;
      var rotatedY = this.verts[i].x * sin + this.verts[i].y * cos;

      bounds.push({ x: rotatedX + this.x, y: rotatedY + this.y });
    }
    return bounds;
  };

  this.buildCanvas = function () {
    this.img = document.createElement('canvas');
    this.img.width = this.width;
    this.img.height = this.height;
    var ctx = this.img.getContext('2d');
    ctx.translate(this.width / 2, this.height / 2);
    this.drawCanvas(ctx);
  };

  this.drawCanvas = function (ctx) {
    // fillColor is optional - see setDrawColors() in GraphicsCommoin.js
    setDrawColors(ctx, this.fillColor); // it's okay if fillColor is undefined. see Asteroid() for example
    ctx.beginPath();
    ctx.moveTo(this.verts[0].x, this.verts[0].y);
    for (var i = 0; i < this.verts.length; i++) {
      ctx.lineTo(this.verts[i].x, this.verts[i].y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  };

  this.draw = function () {
    if (this.img) {
      drawBitmapCenteredWithRotation(this.img, this.x, this.y, this.ang);

      if (DRAW_ASTEROIDS_WRAPPED) {
        var onEdge = false;
        var clone_offset_x = 0;
        var clone_offset_y = 0;
        var maxx = canvas.width - this.radius;
        var maxy = canvas.height - this.radius;
        var minx = this.radius;
        var miny = this.radius;
        if (this.x > maxx) {
          clone_offset_x = -canvas.width;onEdge = true;
        }
        if (this.x < minx) {
          clone_offset_x = canvas.width;onEdge = true;
        }
        if (this.y > maxy) {
          clone_offset_y = -canvas.height;onEdge = true;
        }
        if (this.y < miny) {
          clone_offset_y = canvas.height;onEdge = true;
        }
        if (onEdge) {
          drawBitmapCenteredWithRotation(this.img, this.x + clone_offset_x, this.y + clone_offset_y, this.ang);
        }
      }
    }

    if (DEBUG) {
      var bounds = this.bounds();
      for (var i = 0; i < bounds.length; i++) {
        strokeCircle(bounds[i].x, bounds[i].y, 5, 'red');
      }

      if (this.radius) {
        strokeCircle(this.x, this.y, this.radius, 'green');
      }
    }
  };
}var RAIL_SPEED = 15.0;
var RAIL_LIFE = 3000;
var SHOT_OFFSET = 30;

RailSlug.prototype = new MovingWrapPosition();

function RailSlug() {
  this.attackValue = 4;

  this.width = 40;
  this.height = 5;
  this.halfWidth = this.width / 2;
  this.halfHeight = this.height / 2;

  this.verts = [];

  this.x = canvas.width / 2;
  this.y = canvas.height / 2;
  this.xv = 0;
  this.yv = 0;

  this.deltaX = 0;
  this.deltaY = 0;

  this.edgeCrossCount = 0;

  this.railColor = 'red';

  this.shotLife = 30;
  this.timeUntilCanHitAgain = 0;

  this.ang = 0;

  this.superClassReset = this.reset;
  this.reset = function () {
    this.superClassReset();
    this.shotLife = 0;
    //shipCanMove = false;
  }; // end of shotReset func

  this.isShotReadyToFire = function () {
    if (this.shotLife <= 0) {
      return true;
    }
  };

  this.countdownTimeUntilCanHitAgain = function () {
    if (this.timeUntilCanHitAgain > 0) {
      this.timeUntilCanHitAgain--;
      //console.log(this.timeUntilCanHitAgain);
    }
  };

  this.shootFrom = function (shipFiring) {
    Stats();
    var shotDistFromShipCenter = SHIP_COLLISION_RADIUS + 2;
    this.x = shipFiring.x + Math.cos(shipFiring.ang) * shotDistFromShipCenter;
    this.y = shipFiring.y + Math.sin(shipFiring.ang) * shotDistFromShipCenter;

    this.xv = Math.cos(shipFiring.ang) * RAIL_SPEED + shipFiring.xv;
    this.yv = Math.sin(shipFiring.ang) * RAIL_SPEED + shipFiring.yv;

    this.ang = shipFiring.ang;

    this.shotLife = RAIL_LIFE;

    timesShot++;
  };

  this.increaseScoreMultiplier = function () {
    if (scoreMultiplier < 4) {
      scoreMultiplier *= 4;
      timesShotWrap++;
    } else {
      shipCanMove = true;
      scoreMultiplier = 1;
      this.shotLife = 0;
    }
  };

  this.handleScreenWrap = function () {
    var edgeCrossed = false;
    if (this.x > canvas.width) {
      this.x = 0;
      edgeCrossed = true;
    }
    if (this.x < 0) {
      this.x = canvas.width;
      edgeCrossed = true;
    }
    if (this.y < 0) {
      this.y = canvas.height;
      edgeCrossed = true;
    }
    if (this.y > canvas.height) {
      this.y = 0;
      edgeCrossed = true;
    }
    if (edgeCrossed) {
      this.edgeCrossCount++;
      this.increaseScoreMultiplier();
      var tempBlit = new Blit(randomInteger(1, canvas.width), randomInteger(0, canvas.height), canvas.width, randomInteger(1, 150), randomInteger(1, 600), randomInteger(0, canvas.height));
      blits.push(tempBlit);
    }
  };

  this.recalcVerts = function () {
    this.halfWidth = this.width / 2;
    this.halfHeight = this.height / 2;

    this.verts = [{ x: -this.halfWidth, y: this.halfHeight }, { x: this.halfWidth, y: this.halfHeight }, { x: this.halfWidth, y: -this.halfHeight }, { x: -this.halfWidth, y: -this.halfHeight }];

    this.radius = Math.sqrt(this.halfWidth * this.halfWidth + this.halfHeight * this.halfHeight);
  };
  // Make sure we have some verts to start with.
  this.recalcVerts();

  //this.superClassMove	=	this.move; //saving reference to parent class' move.
  this.move = function () {
    //console.log(this.shotLife);
    if (this.shotLife == 0) {
      //console.log('can move again');
      scoreMultiplier = 1;
    }
    if (this.shotLife > 0) {
      //console.log('cannot move right now');
      this.shotLife--;
      this.x += this.xv;
      this.y += this.yv;
      this.handleScreenWrap();
    }
  };

  this.superClassDraw = this.draw;
  this.draw = function () {
    if (scoreMultiplier == 1) {
      this.railColor = 'white';
      scoreMultiplierLifeSpan = MULTIPLIER_LIFESPAN;
    }

    if (testingCheats == true || scoreMultiplier == 4) {
      this.railColor = 'blue';
      scoreMultiplierLifeSpan = MULTIPLIER_LIFESPAN;
      this.height = 50;
      this.width = 400;
      this.recalcVerts();
    }

    if (this.shotLife > 0) {
      colorRotatedRect(this.x, this.y, this.width, this.height, this.railColor, this.ang);
      this.superClassDraw();
    }
  };
}

var SPACESPEED_DECAY_MULT = 0.99;
var THRUST_POWER = 0.075;
var TURN_RATE = 0.015;
var SHIP_COLLISION_RADIUS = 30;

var MULTIPLIER_LIFESPAN = 150;

var shipCanMove = true;
var endScore;
var endWave;
var scoreMultiplier = 1;
var scoreMultiplierLifeSpan = MULTIPLIER_LIFESPAN;

Ship.prototype = new MovingWrapPosition();

function Ship() {

  this.cannon = new Cannon();

  this.x = canvas.width / 2;
  this.y = canvas.height / 2;
  this.x2; //rotated location of thrusts
  this.y2; //rotated location of thrusts
  // image is 48x32
  this.width = 48;
  this.height = 32;
  this.verts = [{ x: -16, y: -13 }, { x: -16, y: 13 }, { x: 16, y: 0 }];
  this.radius = 21;
  this.ang = 0;
  this.xv = 0;
  this.yv = 0;

  this.keyHeld_Gas = false;
  this.keyHeld_Reverse = false;
  this.keyHeld_TurnLeft = false;
  this.keyHeld_TurnRight = false;

  this.keyHeld_Fire = false;

  this.controlKeyUp;
  this.controlKeyRight;
  this.controlKeyDown;
  this.controlKeyLeft;

  this.drawCanvas = function (ctx) {
    var lines = [[{ x: -16, y: -13 }, { x: 16, y: 0 }], [{ x: 16, y: 0 }, { x: -16, y: 13 }], [{ x: -9, y: -10 }, { x: -9, y: 10 }]];

    setDrawColors(ctx);
    ctx.beginPath();
    for (var i = 0; i < this.verts.length; i++) {
      ctx.moveTo(lines[i][0].x, lines[i][0].y);
      ctx.lineTo(lines[i][1].x, lines[i][1].y);
    }
    ctx.stroke();
  };
  this.buildCanvas();

  this.setupInput = function (upKey, rightKey, downKey, leftKey, shotKey) {
    this.controlKeyUp = upKey;
    this.controlKeyRight = rightKey;
    this.controlKeyDown = downKey;
    this.controlKeyLeft = leftKey;
    this.controlKeyForShotFire = shotKey;
  };

  this.superClassReset = this.reset;
  this.reset = function () {
    this.superClassReset();
    this.xv = this.yv = 0.0;
    this.cannon.clearShots();
  }; // end of shipReset func

  this.checkMyShipCollisonAgainst = function (colliders) {
    for (var c = 0; c < colliders.length; c++) {
      if (checkCollisionShapes(this, colliders[c])) {
        if (isInHyperSpace === false) {
          resetRound();
        }
        if (testingCheats) {
          console.log('player collison detected - cheatmode on!');
          return;
        }
      } // check if the current collider is overlapping the ship
    } //loop through colliders
  }; //end of checkMyShipCollisonAgainst functions

  this.superClassMove = this.move;
  this.move = function (colliders) {

    if (scoreMultiplierLifeSpan > 0) {
      scoreMultiplierLifeSpan--;
    }
    if (scoreMultiplierLifeSpan == 0) {
      scoreMultiplier = 1;
    }

    if (this.keyHeld_Gas && shipCanMove == true) {
      fuelUsed++;
      this.xv += Math.cos(this.ang) * THRUST_POWER;
      this.yv += Math.sin(this.ang) * THRUST_POWER;
      createParticles(this.x + this.x2, this.y + this.y2);

      createParticles(this.x + this.x3, this.y + this.y3);
    }
    if (this.keyHeld_TurnLeft && shipCanMove == true) {
      this.ang -= TURN_RATE * Math.PI;
      createParticles(this.x + this.x3, this.y + this.y3);
    }
    if (this.keyHeld_TurnRight && shipCanMove == true) {
      this.ang += TURN_RATE * Math.PI;
      createParticles(this.x + this.x2, this.y + this.y2);
    }

    this.xv *= SPACESPEED_DECAY_MULT;
    this.yv *= SPACESPEED_DECAY_MULT;

    var DISTCENTERTOTHRUST1 = -10; //lenght from center of ship pic to thrust1
    var DISTCENTERTOTHRUST2 = -10; //lenght from center of ship pic to thrust2

    //thurst positions
    var thrust1ang = 1.95 * Math.PI + this.ang;
    var thrust2ang = 1.61 * Math.PI + this.ang;
    this.x2 = Math.cos(thrust1ang) * DISTCENTERTOTHRUST1 - Math.sin(thrust1ang) * DISTCENTERTOTHRUST1;
    this.y2 = Math.sin(thrust1ang) * DISTCENTERTOTHRUST1 + Math.cos(thrust1ang) * DISTCENTERTOTHRUST1;
    this.x3 = Math.cos(thrust2ang) * DISTCENTERTOTHRUST2 - Math.sin(thrust2ang) * DISTCENTERTOTHRUST2;
    this.y3 = Math.sin(thrust2ang) * DISTCENTERTOTHRUST2 + Math.cos(thrust2ang) * DISTCENTERTOTHRUST2;

    this.superClassMove();
    this.checkMyShipCollisonAgainst(colliders);
    //this.cannon.iterateThroughEnemyArray(colliders, this);
    this.cannon.iterateShotsandColliders(colliders, this);
  };

  this.superClassDraw = this.draw;
  this.draw = function () {
    this.cannon.drawShots();
    this.superClassDraw();
  };
}
/*
  Sound class to manage the loading, playing, etc. of html5 audio elements
*/
var Sound = {};

//list of path, file name
Sound.queue = [["music/", "spacepool-low-volume.wav"], ["music/", "tape-1.wav"], ["music/", "tape-2.wav"], ["music/", "tape-3.wav"], ["music/", "tape-4.wav"], ["music/", "drift.wav"]];

//for load checking
Sound.numLoaded = 0;

//cache of loaded sound assets
Sound.cache = {};

//load sounds
Sound.load = function (callBack) {
  var _this = this;

  /*
    array.map works with => as if you were looping over an anonymous function.
    The same could have been done with:
    for ( var i = 0; i < this.queue.length; ++i ) {
      var s = this.queue[ i ];
      //do stuff with s
    }
     OR:
    this.queue.map(function( s ) {
     //do stuff with s
    });
  */
  this.queue.map(function (s) {
    var filePath = s,

    //getting file name e.g. _spacepool.wav
    fileName = filePath[1].split('.')[0],
        audio = new Audio();

    /*
      setting source as you would to an element
      created by document.createElement("audio")
    */
    audio.src = filePath[0] + filePath[1];

    /*
      Audio elements in html5 have a "canplaythrough" property which
      can be used much like the load property for img elements.
       Using the same syntax as above to invoke an anonymous function
      as shorthand to execute whatever function is passed as the
      "callback" parameter within our Sound.load method when the
      elements that can play through equal our initial queue length.
    */
    audio.addEventListener("canplaythrough", function () {
      ++_this.numLoaded;
      if (_this.numLoaded == _this.queue.length) {
        callBack();
      }
    }, false);

    /*
      Adding the modified Audio element to our cache of loaded sounds
      so we can reference it easily by file name without the extension,
      e.g. _spacepool.wav becomes just _spacepool
    */
    _this.cache[fileName] = audio;
  });
};

/*
  Audio.playbackRate modifies the speed at which
  the audio is played. playbackRate takes a value between 0.5 and 4:
  e.g. playbackRate = .5 will play at half speed,
       playbackRate = 2 will play at double
*/
Sound.playbackRate = function (fileName, playbackRate) {
  if (this.cache[fileName] == null) return;

  if (playbackRate != undefined) this.cache[fileName].playbackRate = playbackRate;
};

/*
  Audio.volume is controlled by a value between 0 - 1:
  e.g. volume = 1 is the loudest, volume = 0 is mute
*/
Sound.volume = function (fileName, volume) {
  if (this.cache[fileName] == null) return;

  if (volume != undefined) this.cache[fileName].volume = volume;
};

/*
  Audio elements have a loop property that when set to true
  will play the sound on loop
*/
Sound.loop = function (fileName, loop) {
  if (this.cache[fileName] == null) return;

  if (loop != undefined) this.cache[fileName].loop = loop;
};

/*
  For simplicity sake we have a Sound.play function which
  gets the Audio element from the cache and sets its currentTime
  to 0 which brings the audio back to the beginning before playing
  if trigged again before finishing its playthrough.

  Leveraging the volume control from above.
*/
Sound.play = function (fileName, volume, loop, playbackRate) {
  if (this.cache[fileName] == null) return;

  this.volume(fileName, volume);
  this.loop(fileName, loop);
  this.playbackRate(fileName, playbackRate);

  var audio = this.cache[fileName];
  audio.currentTime = 0;
  audio.play();
};
function Stats() {
  //Avg game shots that wrapped
  avgTimesShotsWrapped = timesShotWrap / timesShot;
  accuracy = asteroidsHit / timesShot;
}
function drawUI() {
  var upperRightText = 'lives: ' + lives + ' ' + 'score: ' + ' ' + score.toString() + ' ' + scoreMultiplier.toString() + 'x';
  canvasContext.font = "14px Arial";
  //colorText(upperRightText, canvas.width - 100, 50, 'white'); //REMOVING SCORE TEMPORARILY TO DEGAMIFY
  if (testingCheats) {
    canvasContext.textAlign = 'left';
    colorText('CHEATS ENABLED, C KEY TO TOGGLE', 80, 50, 'red');
    canvasContext.textAlign = 'center';
  }
}

function titleScreen() {
  var titleText = "Drift Bravely";
  var subText = "up to increase speed, left and right to turn";
  var subSubText = "space to fire, enter to start";
  canvasContext.fillStyle = "white";
  canvasContext.textAlign = "center";
  canvasContext.font = "14px Arial";
  canvasContext.fillText(subText, canvas.width / 2, 270);
  canvasContext.font = "14px Arial";
  canvasContext.fillText(subSubText, canvas.width / 2, 300);
  canvasContext.font = "20px Arial";
  canvasContext.fillText(titleText, canvas.width / 2, 250);
}

function gameOverScreen() {
  var titleText;
  if (lives == 0) {
    titleText = "game over";
  } else {
    titleText = "ouch you died!";
  }
  var subText = "score: " + endScore + " waves reached: " + endWave;
  var subSubText = "press enter to reset";
  canvasContext.fillStyle = "white";
  canvasContext.textAlign = "center";
  canvasContext.font = "14px Arial";
  if (lives == 0) {
    canvasContext.fillText(subText, canvas.width / 2, 270);
  }
  canvasContext.font = "14px Arial";
  canvasContext.fillText(subSubText, canvas.width / 2, 300);
  canvasContext.font = "20px Arial";
  canvasContext.fillText(titleText, canvas.width / 2, 250);
  Stats();
  /*
  timesShotWrap=0;
  timesShot=0;
  asteroidsHit=0;
  fuelUsed=0;
  accuracy=0;
  */
}

function pauseScreen() {
  var titleText = "Game Paused";
  var subText = "press P to continue";
  colorRotatedRect(canvas.width / 2, canvas.height / 2, canvas.width * 0.90, canvas.height * 0.90, 'rgba(64,64,64,0.1)', 0);
  canvasContext.fillStyle = "white";
  canvasContext.textAlign = "center";
  canvasContext.font = "20px Arial";
  canvasContext.fillText(titleText, canvas.width / 2, 250);
  canvasContext.font = "14px Arial";
  canvasContext.fillText(subText, canvas.width / 2, 270);
}
var waveController; //Initialized in window.onLoad

function WaveController() {
  this.initialSpeed = 0.01;
  this.speed = this.initialSpeed;
  this.active = false;
  this.scale = 1;
  this.doubleWave = false;
  this.reset = function () {};

  //Setup a new canvas to hold the gradient image
  this.gradientCanvas = document.createElement('canvas');
  this.gradientCanvas.id = 'gradientCanvas';
  this.gradientCanvas.style.display = 'none';
  this.gradientCanvasContext = this.gradientCanvas.getContext('2d');
  this.gradientCanvas.width = canvas.width;
  this.gradientCanvas.height = canvas.width;

  //Draw the gradient to gradientCanvas
  setupGradient(this.gradientCanvasContext);

  //Create a new outbound wave
  this.startSingleWave = function () {
    this.doubleWave = false;
    this.initializeWave();
  };

  //Create a new outbound returning wave
  this.startDoubleWave = function () {
    this.doubleWave = true;
    this.initializeWave();
  };

  //Reset wave parameters and start the wave
  this.initializeWave = function () {
    this.active = true;
    this.scale = 0.01;
    this.speed = this.initialSpeed;
  };

  this.drawWave = function () {
    if (this.active) {
      var size = canvas.width * this.scale;
      canvasContext.drawImage(this.gradientCanvas, canvas.width / 2 - size / 2, canvas.height / 2 - size / 2, size, size);
      this.scale += this.speed;

      //Wave is at max size
      if (this.scale >= 1.415) {
        //diagonal of a square = sqrt(2)
        stopSliding();
        if (this.doubleWave) {
          //Returns the wave
          this.speed = -this.initialSpeed;
        } else {
          //Kills the wave
          this.active = false;
        }
      } else if (this.scale < 0) {
        //Kills the wave and resets parameters for next wave
        this.active = false;
      }
    }
  };
}

function setupGradient(context) {
  var coord = canvas.width / 2;
  var waveWidth = 30;
  var gradient = context.createRadialGradient(coord, coord, coord - waveWidth, coord, coord, coord);
  gradient.addColorStop(0, "black");
  gradient.addColorStop(1, "white");

  context.arc(coord, coord, coord, 0, 2 * Math.PI);

  context.fillStyle = gradient;
  context.fill();
}
// Christer McFunkypants Kaitila's Gamepad Keyboard Emulator
// Sends fake keyboard events to the browser by polling the gamepad (if any).
// plug-n-play: addd gamepad support to keyboard-only games.

var joystick = new GamepadKeyboardEventEmulator();

function GamepadKeyboardEventEmulator() {
  var gamepad = null;
  var gamepad_left = false;
  var gamepad_right = false;
  var gamepad_up = false;
  var gamepad_down = false;
  var gamepad_fire = false;
  var gamepad_jump = false;
  var prev_gamepad_left = false;
  var prev_gamepad_right = false;
  var prev_gamepad_up = false;
  var prev_gamepad_down = false;
  var prev_gamepad_fire = false;
  var prev_gamepad_jump = false;

  var SIMULATED_KEY_LEFT = 37;
  var SIMULATED_KEY_RIGHT = 39;
  var SIMULATED_KEY_UP = 38;
  var SIMULATED_KEY_DOWN = 40;
  var SIMULATED_KEY_FIRE = 13; // [B] button = enter
  var SIMULATED_KEY_JUMP = 32; // [A] button = space

  window.addEventListener("gamepadconnected", function (e) {
    // Gamepad connected
    console.log("Gamepad connected", e.gamepad);
  });

  window.addEventListener("gamepaddisconnected", function (e) {
    // Gamepad disconnected
    console.log("Gamepad disconnected", e.gamepad);
  });

  function applyDeadzone(number, threshold) {
    var percentage = (Math.abs(number) - threshold) / (1 - threshold);
    if (percentage < 0) {
      percentage = 0;
    }
    return percentage * (number > 0 ? 1 : -1);
  }

  function handle_gamepad() {
    if (!gamepad) // always null until you press a button!
      {
        //console.log("Init gamepad..."); // spammy
        if (!navigator.getGamepads) {
          console.log("Gamepad NOT supported on this browser!");
          return; // not supported?
        }
      }
    // poll every frame
    gamepad = navigator.getGamepads()[0];
    if (gamepad) {
      //console.log("Gamepad detected: " + gamepad.axes[0] + "," + gamepad.axes[1]);
      var joystickX = applyDeadzone(gamepad.axes[0], 0.25);
      gamepad_right = joystickX > 0;
      gamepad_left = joystickX < 0;
      var joystickY = applyDeadzone(gamepad.axes[1], 0.25);
      gamepad_down = joystickY > 0;
      gamepad_up = joystickY < 0;
      var butt = applyDeadzone(gamepad.buttons[0].value, 0.25);
      //gamepad_up = gamepad_up || (butt>0);
      gamepad_jump = butt > 0;
      butt = applyDeadzone(gamepad.buttons[1].value, 0.25);
      gamepad_fire = butt > 0;
    } else {}
    //console.log("No gamepad detected! YET..."); // spammy before button press


    // compare previous state and send fake keyboard events
    fake_keyboard_events();

    window.requestAnimationFrame(handle_gamepad);
  }

  function fake_keyboard_events() // if any
  {
    // compare previous state
    if (!prev_gamepad_left && gamepad_left) simulateKeyDown(SIMULATED_KEY_LEFT);
    if (!prev_gamepad_right && gamepad_right) simulateKeyDown(SIMULATED_KEY_RIGHT);
    if (!prev_gamepad_up && gamepad_up) simulateKeyDown(SIMULATED_KEY_UP);
    if (!prev_gamepad_down && gamepad_down) simulateKeyDown(SIMULATED_KEY_DOWN);
    if (!prev_gamepad_fire && gamepad_fire) simulateKeyDown(SIMULATED_KEY_FIRE);
    if (!prev_gamepad_jump && gamepad_jump) simulateKeyDown(SIMULATED_KEY_JUMP);
    // only sends events if state has changed
    if (prev_gamepad_left && !gamepad_left) simulateKeyUp(SIMULATED_KEY_LEFT);
    if (prev_gamepad_right && !gamepad_right) simulateKeyUp(SIMULATED_KEY_RIGHT);
    if (prev_gamepad_up && !gamepad_up) simulateKeyUp(SIMULATED_KEY_UP);
    if (prev_gamepad_down && !gamepad_down) simulateKeyUp(SIMULATED_KEY_DOWN);
    if (prev_gamepad_fire && !gamepad_fire) simulateKeyUp(SIMULATED_KEY_FIRE);
    if (prev_gamepad_jump && !gamepad_jump) simulateKeyUp(SIMULATED_KEY_JUMP);
    // now remember current state
    prev_gamepad_left = gamepad_left;
    prev_gamepad_right = gamepad_right;
    prev_gamepad_up = gamepad_up;
    prev_gamepad_down = gamepad_down;
    prev_gamepad_fire = gamepad_fire;
    prev_gamepad_jump = gamepad_jump;
  }

  function simulateKeyDown(thisKey) {
    //console.log('fake keydown: ' + thisKey)
    var oEvent = document.createEvent('KeyboardEvent');
    Object.defineProperty(oEvent, 'keyCode', { get: function get() {
        return this.keyCodeVal;
      } });
    Object.defineProperty(oEvent, 'which', { get: function get() {
        return this.keyCodeVal;
      } });
    if (oEvent.initKeyboardEvent) {
      oEvent.initKeyboardEvent("keydown", true, true, document.defaultView, false, false, false, false, thisKey, thisKey);
    } else {
      oEvent.initKeyEvent("keydown", true, true, document.defaultView, false, false, false, false, thisKey, 0);
    }
    oEvent.keyCodeVal = thisKey;
    document.dispatchEvent(oEvent);
  }

  function simulateKeyUp(thisKey) {
    //console.log('fake keyup: ' + thisKey)
    var oEvent = document.createEvent('KeyboardEvent');
    Object.defineProperty(oEvent, 'keyCode', { get: function get() {
        return this.keyCodeVal;
      } });
    Object.defineProperty(oEvent, 'which', { get: function get() {
        return this.keyCodeVal;
      } });
    if (oEvent.initKeyboardEvent) {
      oEvent.initKeyboardEvent("keyup", true, true, document.defaultView, false, false, false, false, thisKey, thisKey);
    } else {
      oEvent.initKeyEvent("keyup", true, true, document.defaultView, false, false, false, false, thisKey, 0);
    }
    oEvent.keyCodeVal = thisKey;
    document.dispatchEvent(oEvent);
  }

  // init
  console.log('Initializing gamepad support...');
  window.requestAnimationFrame(handle_gamepad);
} // GamepadKeyboardEventEmulator